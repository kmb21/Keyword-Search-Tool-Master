
$$@@$$PAGE: 1
a transition guide from python 2x to c
michael h goldwasser

david letscher

saint louis university

august 2011 revision
all rights reserved by the authors

this is a supplement to the book
objectoriented programming in python
prenticehall 2007
isbn13 9780136150312

1


$$@@$$PAGE: 2
contents
1 introduction

4

2 programming language design
21 interpreted versus compiled                                
22 dynamic versus static typing                               

4
4
5

3 a first glance at c
31 superficial differences
32 static typing     
33 input and output  
34 executing a program 




























































































































































7
7
8
9
9

4 data types and operators
41 primitive data types     
42 declarations and initialization 
43 operators            
44 converting between types  























































































































































10
10
13
15
17

5 control structures
51 while loops               
52 conditionals               
53 nonboolean expressions as conditions
54 for loops                
55 defining a function          





























































































































































18
18
18
19
20
21

6 input and output
61 necessary libraries
62 console output  
63 formatted output
64 console input   
65 file streams    
66 string streams  























































































































































































21
22
22
22
24
26
27

7 classes in c
71 using instances of a class                                 
72 defining a class                                      
73 inheritance                                         

28
28
29
33

8 object models and memory management
81 value variables                        
82 reference variables                      
83 pointer variables                       
84 dynamic memory management               
85 treatment of arrays                     
86 constructors destructors and the assignment operator 

36
37
38
40
41
41
43


































































































2











































































































$$@@$$PAGE: 3
9 generic programming and templates
47
91 templated functions                                     48
92 templated classes                                      49
93 using templated functions and classes                          50
10 c containers and
101 the vector class 
102 other stl classes
103 iterators      

the standard
        
        
        

template library
53
                            53
                            54
                            55

11 error checking and exceptions
111 overview               
112 throwing an exception       
113 catching an exception        
114 other approaches to errorhandling
12 managing large projects
121 compilation and linking  
122 avoiding multiple definitions
123 namespaces          
124 managing class definitions 
125 managing templated classes
126 unit testing          
127 documentation        






























































































































































































































































































































































56
56
56
57
58









59
60
62
62
63
66
67
67

a full source code
68
a1 tally sheet and frequency counting                            68
a2 mastermind                                          68

3


$$@@$$PAGE: 4
2 programming language design

1

page 4

introduction

python is a wonderful programming language however more than a thousand programming
languages have been developed over time with perhaps a hundred that are still actively used for
program development each language has its own strengths and weaknesses in trying to support
the development of efficient maintainable and reusable software software professionals must
become accustomed to programming in different languages fortunately once a person has a solid
foundation in one language it becomes easier to transition to programming in another language
this document is designed for python programmers choosing c as a second language c
is a widely used language in industry and as an objectoriented language it has much in common
with python yet there exist significant differences between the two languages this transition
guide is not meant to serve as a complete selfcontained reference for c our goal is to provide
an initial bridge built upon the knowledge and terminology introduced in our book objectoriented
programming in python
c is a direct extension of an earlier programming language named c the c programming
language was introduced in 1973 and widely used for software development for decades in fact
its use is still prevalent its greatest strength is its runtime efficiency however it is not objectoriented in the early 1980s developers at bell labs began work on c adding support for
object orientation while preserving aspects of the original syntax of c as a result c provides
a more robust set of existing libraries while still providing the ability to create fast executables
c and c provide great flexibility in controlling many of the underlying mechanisms used
by an executing program a programmer can control lowlevel aspects of how data is stored how
information is passed and how memory is managed when used properly this control can lead
to a more streamlined result furthermore because of the long history of c and c and their
widespread use the technology has been highly optimized
the greatest weakness of c is its complexity ironically this weakness goes handinhand
with the very issues that we described as strengths of the language with decades of prominence
its evolution has been somewhat restricted by the desire to remain backward compatible in support
of the large body of existing software some additional features have been retrofitted in a more
awkward way than if the language had been developed with a clean slate as a result parts of the
syntax have grown cryptic more significantly the flexibility given to a programmer for controlling
lowlevel aspects comes with responsibility rather than one way to express something there may
be five alternatives an experienced and knowledgeable developer can use this flexibility to pick
the best alternative and improve the result yet both novice and experienced programmers can
easily choose the wrong alternative leading to less efficient or flawed software

2
21

programming language design
interpreted versus compiled

chapter 13 of our book describes the distinction between lowlevel and highlevel programming
languages at its core a computing architecture supports an extremely limited set of data types
and operations for this reason we describe a cpus machine language as a lowlevel programming
language it is possible to develop software directly for that machine language especially with
applications for which execution speed is of utmost concern however it is extremely inconvenient
to develop complex software systems in a lowlevel language highlevel programming languages
were conceived to better support a programmers expressiveness thereby reducing the development
time of software systems providing greater opportunity for code reuse and improving the overall
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 5
2 programming language design

page 5

reliability and maintainability of software but that highlevel software must be translated back
to a cpus machine language in order to execute on that computer this translation is typically
automated in the form of an interpreter or compiler
python is an example of an interpreted language we run a typical python program by
feeding its source code as input to another piece of software known as the python interpreter the
python interpreter is the software that is actually executing on the cpu in effect adapting its
outward behavior to match the semantics indicated by the given source code the translation from
highlevel to lowlevel operations is performed onthefly1 
in contrast c is an example of a compiled language the translation of highlevel source
code to lowlevel machine code takes place in advance of the software being executed by the end
user relying on a distinct twophase process during the first phase compiletime the source
code is fed as input to a special piece of software known as the compiler the compiler analyzes
the source code based on the syntax of the language if there are syntax errors they are reported
and the compilation fails otherwise the compiler translates the highlevel code into machine code
for the computing system generating a file known as an executable during the second phase
runtime the executable is started on a computer often by a user we note that the compiled
executable is catered to one particular machine language different versions of the executable must
be distributed for use on different computing platforms yet the compiler and the original source
code are not required to run the executable on a given computer they would only be needed by
the developer to regenerate a new executable if any change were to be made to the software
the greatest advantage of the compilation model is execution speed in essence the more that
can be handled at compiletime the fewer cpu cycles are spent at runtime by performing the
full translation to machine code in advance the execution of the software is streamlined so as to
perform only those computations that are a direct part of the software application a secondary
advantage is that the executable can be distributed to customers as freestanding software ie
without need for an installed interpreter and without exposing the original source code that was
used to generate it although some companies choose to open source their software
the primary advantage of an interpreted language is greater platformindependence as the
primary source code can be widely distributed with the platformspecific translations enacted by
a locallyinstalled interpreter a secondary advantage of interpreters is that they often support
more dynamic language features since analysis or even modifcation of code fragments can be
performed at runtime and they can serve a dual role as a development platform providing the
programmer with more robust feedback and interaction when problems arise

22

dynamic versus static typing

we noted that for compiled languages there is an advantage in doing as much work as possible at
compiletime so as to streamline the runtime process it is this fact that motivates the single greatest distinction between python and c python is a dynamicallytyped language an identifier
can be assigned to an underlying value within a given scope using an assignment statement such as
age  42
we happen to know that age is being assigned to an integer value in this case yet we did not make
any syntactic declaration regarding the data type that same identifier could later be reassigned
to the string stone types are not formally associated with the identifiers but rather with the
1

technically a small amount of compilation takes place in python when parsing the source code that portion of
the translation results in a saved pyc file that can be reused on a later execution to avoid reparsing the code

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 6
2 programming language design

page 6

underlying objects in effect the value 42 knows that it is an integer when identifiers are used
in expressions the legitimacy depends upon the type of the underlying object the expression
age  1 will be valid when age is an integer yet invalid when age is a string the method call
agelower  will be legal when age is a string yet illegal when age is an integer
in python these expressions are evaluated at runtime when encountering an expression such
as agelower  the interpreter determines whether the object currently associated with the name
age supports the syntax lower  if so the expression is evaluated successfully if not a runtime error occurs the same principle of dynamic typing applies to the declaration of functions
the formal parameters in the signature serve as placeholders for the required number of actual
parameters yet there is no explicit statement of type these identifiers are assigned to the actual
objects sent by the caller at runtime class definitions also rely on dynamic typing for the data
members which are generally initialized in the constructor but never explicitly declared
python style of waiting until runtime to evaluate the legitimacy of commands is known as
duck typing if it walks like a duck and quacks like a duck then for all intents and purposes it is
a duck this flexibility allows for various forms of polymorphism for example the sum function
accepts a parameter that is assumed to be a sequence of numbers it works whether that sequence is
in the form of a list a tuple or a set so long as the parameter is iterable yet python also allows you
to query the type of an object at runtime allowing for another form of polymorphism a function
can vary its behavior based upon the type of an actual parameter for example in chapter 62 of
our book we provided a point mul implementation that specialized the multiplication semantics
depending upon whether the actual parameter was a scalar value or another point
c is a staticallytyped language an explicit type declaration is required for every identifier
the following demonstrates a type declaration followed by an assignment
int age
age  42
the first line is a declaration that establishes the identifier age as an integer value in the current
scope and the second line is an assignment statement that sets the value of the variable it is also
possible to initialize the value as part of a declaration statement see section 42 for details type
declarations appear in many contexts making explicit the type of parameters and return values for
functions and the type of data members stored by an instance of a class
the reason for requiring programmers to make such declarations is that it allows for significantly
more work to be done at compiletime rather than runtime for example the legality of the
subsequent assignment age  42 is apparent at compiletime based upon knowledge of the data
type in similar spirit if a programmer attempts to send a string to a function that expects
a floatingpoint number as in sqrthello this error can be detected at compiletime type
declarations also help the system in better managing the use of memory
the choice between dynamically versus staticallytyped languages is often though not always
paired with the choice between interpreted and compiled languages the primary advantage of
static typing is the earlier detection of errors this early detection is more significant with a compiled
language for which there is a distinction between compiletime errors and runtime errors even if
static typing is used in a purely interpreted language those errors will not arise until the program is
executed the primary advantages of dynamic typing are the reduced syntactical burden associated
with explicit declarations together with more direct support for polymorphism

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 7
3 a first glance at c

3

page 7

a first glance at c

as our first example figure 1 presents a sidebyside view of corresponding python and c
programs both ask the user to enter two integers computing and displaying their greatest common
divisor in this section we highlight some difference between the two languages

31

superficial differences

we first draw attention to the use of punctuation in c for delimiting the basic syntactic structure
of the code an individual command in python eg u  v is followed by a newline character
designating the end of that command in c each statement must be explicitly terminated with
a semicolon for example we see the semicolon after the command u  v on line 10
there is also a difference in designating a block of code in python each block is preceded by
a colon with indentation subsequently used to designate the extent of a multiline block in c
these blocks of code are explicitly enclosed in curly braces   the body of the while loop in the
c version consists of everything from the opening brace at the end of line 8 until the matching
right brace on line 12 that loop is itself nested within the function body that begins with the left
brace on line 4 and concludes with the right brace on line 14
python
1 def gcdu v
2
 we will use euclids algorithm
3
 for computing the gcd
4
while v  0
5
r  u  v  compute remainder
6
uv
7
vr
8
return u
9
10 if name  __main__
11
a  intraw inputfirst value 
12
b  intraw inputsecond value 
13
print gcd gcdab

c
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24

include iostream
using namespace std
int gcdint u int v 
 we will use euclids algorithm
for computing the gcd 
int r
while v  0 
r  u  v  compute remainder
u  v
v  r

return u

int main  
int a b
cout  first value 
cin  a
cout  second value 
cin  b
cout  gcd   gcdab  endl
return 0


figure 1 programs for computing a greatest common divisor as written in python and c

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 8
3 a first glance at c

page 8

for the most part the use of whitespace is irrelevant in c although our sample code is
spaced with one command per line and with indentation to highlight the block structure these are
not formal requirements of the language syntax for example the definition of the gcd function
could technically be expressed in a single line as follows
int gcdint u int v  int r while v  0  r  u  v u  v v  r  return u 
to the compiler this is the same definition as our original of course to a human reader this
version is nearly incomprehensible so as you transition from python we ask that you continue
using whitespace to make your source code legible
this first example demonstrates a few other superficial differences c requires the boolean
condition for a while loop to be expressed within parentheses see line 8 we do not need to do
so in python see line 4 although parentheses can be used optionally we also see a difference
in the symbols used when providing inlined comments in python the  character is used to
designate the remainder of the line as a comment two different commenting styles are allowed in
c an inlined comment is supported using the  pattern as seen at line 9 another style is
demonstrated on lines 5 and 6 starting with the  pattern and ending with the  pattern this
style is particularly convenient as it can span multiple lines of source code

32

static typing

the more significant differences between the python and c versions of our example involve the
distinction between dynamic and static typing as we originally discussed in section 22 even in
this simple example there are three distinct manifestations of static typing the formal parameters
ie identifiers u and v are declared without any explicit type designation in the python signature
at line 1 in the corresponding declaration of parameters in the c signature we find explicit
type declaration for each parameter within the syntax gcdint u int v this information serves
two purposes for the compiler first it allows the compiler to check the legality of the use of u and
v within the function body second it allows the compiler to enforce that integers be sent when
the function is called as at line 22
the second manifestation of static typing is the explicit designation of the return type as part of
a formal signature in c in line 4 of our c example the declaration int at the beginning of
the line labels gcd as a function that returns an integer again the compiler uses this designation
to check the validity of our own code namely that we are indeed returning the correct type of
information at line 13 as well as to check the callers use of our return value for example if the
caller invokes the function as part of an assignment g  gcd5442 this would be legal if variable g
has been declared as an integer or compatible numeric type yet illegal if g were a string
finally we note the declaration of variable r at line 7 of our c code this designates r as
a local variable representing an integer allowing its use at lines 9 and 11 had we omitted the
original declaration the compiler would report an error cannot find symbol regarding the later
use of r the analog of a nameerror in python formally a declared variable in c has scope
based upon the most specific set of enclosing braces at the point of its declaration in our original
example the variable r has scope as a local variable for the duration of the gcd function body
as is also the case with our python version technically since this variables only purpose is for
temporary storage during a single invocation of the while loop body we could have declared it
within the more narrow scope of the loop body python does not support such a restricted scope

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 9
3 a first glance at c

33

page 9

input and output

python and c differ greatly in the techniques used to support the gathering of input and
production of output we will discuss this topic more thoroughly in section 6 but for now we
examine the use of input and output in our first example from figure 1 in both programs the
goal is to read two integers and then to display the result
we begin by examining the corresponding commands that display the result in python the
builtin print command is used at line 13 to display the string gcd followed by the return value
of the function call gcdab we rely on the fact that the print command automatically inserts an
extra space between the two arguments and a newline character after the final argument
in c input and output is generally managed through an abstraction known as a stream
the definition of a stream must be explicitly imported from a standard library in our first c
example lines 1 and 2 are used to load the necessary definitions into our context the actual display
of the result is accomplished by line 22 of that code the cout identifier represents a special output
stream used to display information to the user console the  symbol is an operator for inserting
data into that output stream in this case we insert the string gcd  followed by the return
value of expression gcdab followed by the identifier endl which represents a newline character
in contrast to our python code we are responsible for explicitly including the separating space as
part of our initial string literal and for inserting the endline character
for gathering input our python version uses the raw input function at lines 11 and 12 each
call to that function prompts the user and then reads a single line of input from the keyboard the
result is returned in the form of a character string because we want to interpret that response
as an integer we explicitly use the int   syntax to construct an integer based upon the parsed
string in c we use the cin object to read input from the user console we must display a
prompt separately as seen at line 18 note the lack of an endline character we then read an
integer from the user at line 19 with the command cin  a the  operator is used to extract
information from the stream into a variable here we see an advantage of cs static typing
we do not need to explicitly convert the read characters into an integer the conversion is implicit
because variable a was already declared to have type int

34

executing a program

finally we examine the treatment of the overall program and the different language models for
executing code starting with python let us assume that the source code is saved in a file gcdpy
the python program is executed by starting the python interpreter while designating the source
code file for example if working directly with the operating system we might issue the command
python gcd  py
the interpreter then begins reading commands from the source code in the case of our example
the interpretation of lines 18 results in the definition of but not the calling of the gcd function
the interpreter continues by executing the body of the if name  __main__ conditional at
lines 1013 technically we could have written this script omitting the conditional at line 10
with the subsequent commands at the toplevel context the advantage of the given style is that
it allows us to differentiate between times when this file is started as the primary source code
and when it is imported as a module from some other context if the command import gcd were
executed from another context the definition of the gcd function would be loaded but lines 1113
would be bypassed this special conditional can be used as a unit test when developing a module
that is part of a larger system

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 10
4 data types and operators

page 10

in c source code must first be compiled a popular compiler is distributed by gnuorg and
typically installed on a system as a program named g if our source code were saved in a file
named gcdcpp the compiler could be invoked from the operating system with the command
g  o gcd gcd  cpp
the compiler will report any syntax errors that it finds if all goes well it produces a new file named
gcd or gcdexe with the windows operating system that is an executable it can be started on
the computer just as you would start any other executable it is also possible to compile c code
using an integrated development environment akin to pythons idle an ide typically relies
upon the same underlying compiler but provides more interactive control of the process
the flow of control for the execution of a c program begins with an implicit call to the
function named main we see this function definition starting at line 16 of our sample c source
code the int return value for main is a technical requirement the value is returned to the
operating system at the conclusion of the program it is up to the operating system to interpret
that value although zero historically indicates a successful execution while other values are used as
error codes such a return value can be specified in python as a parameter to the sysexit function
as a final comment we note that the use of a main function in c is not quite the same as the
if name  __main__ construct in python we discussed how the python technique could
be used to provide a unit test that would be executed when the file is the primary source code
but ignored when that module was imported from elsewhere when a project is implemented with
multiple source files in c the compiler requires that precisely one of them has a main routine
as a consequence the gcd function as provided in our sample gcdcpp file could not be used as
part of a larger project because there would be conflicting definitions for main with a more
typical c style such a utility function would be provided in a file without a main function and
imported as needed by other applications we will discuss the development of multifile projects in
section 12

4
41

data types and operators
primitive data types

figure 2 provides a summary of common primitive data types in c noting the correspondence
to pythons types we emphasize the following aspects of that comparison

boolean values
the logical bool type is supported by both languages although the literals true and false are
uncapitalized in c while capitalized in python in both languages boolean values are stored
internally as integers with false represented using value 0 and true represented as 1

varying precision of numeric types
c offers the programmer more finegrained control in suggesting the underlying precision when
storing numbers there exist three fixedprecision integer types short int and long however
the precise number of bits devoted to these types is systemdependent with typical values shown
in figure 2 pythons int type is usually implemented with the precision of a c long
each of the c integer types has an unsigned variant that is constrained to represent nonnegative numbers for example a variable can be declared with type unsigned short whereas a
signed integer type with b bits has a typical range from 2b1  to 2b1  1 a corresponding
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 11
4 data types and operators

c type

page 11

description

literals

python analog

bool

logical value

true
false

bool

short

integer often 16 bits

int

integer often 32 bits

39

long

integer often 32 or 64 bits

39l



integer arbitraryprecision

float

floatingpoint often 32 bits

314f

double

floatingpoint often 64 bits

314

char

single character

a

stringa

character sequence

hello

int
long

float

str

figure 2 the most common primitive data types in c
a

not technically a builtin type included from within standard libraries

unsigned type would have range from 0 to 2b  1 the greater range of positive numbers can be
used for contexts when a value cannot be negative such as when describing the size of a container
c also supports two different floatingpoint types float and double with a double historically represented using twice as many bits as a float in c the double is most commonly used
and akin to what is named float in python
finally we note that pythons long type serves a completely different purpose representing
integers with unlimited magnitude there is no such standard type in c although some c
packages for arbitraryprecision integers are distributed independently

character strings
c supports two different types for representing text the char type provides an efficient representation of a single character of text while the string class serves a purpose similar to pythons
str class representing a sequence of characters which may happen to be an empty string or a
singlecharacter string to distinguish between a char and a onecharacter string a string literal
must be designated using double quote marks as in a the use of single quotes is reserved for a
char literal as in a an attempt to misuse the singlequote syntax as in impossible results
in a compiletime error
from a technical point of view the string class is not a builtin type it must be included from
among the standard c libraries although the formal methods of the c string class are
not the same as the python str class many behaviors are common however in contrast with
pythons immutable str class a c string is mutable so the expression sindex can be used
to access a particular character or to alter that character with an assignment sindex  newchar
there is a similar discrepancy between the c syntax sappendt which mutates instance s by
appending the contents of string t and the syntax st which produces a concatenation as a third
string leaving the two original strings unchanged a summary of the most commonly used string
operations is given in figures 3 and 4 with figure 3 describing the nonmutating behaviors and
figure 4 describing the mutating behaviors

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 12
4 data types and operators

syntax

page 12

semantics

ssize 
slength 

either form returns the number of characters in string s

sempty 

returns true if s is an empty string false otherwise

sindex

returns the character of string s at the given index
unpredictable when index is out of range

satindex

returns the character of string s at the given index
throws exception when index is out of range

s  t

returns true if strings s and t have same contents false otherwise

st

returns true if s is lexicographical less than t false otherwise

scomparet

returns a negative value if string s is lexicographical less than string t zero if
equal and a positive value if s is greater than t

sfindpattern
sfindpattern pos

returns the least index greater than or equal to index pos if given at which
pattern begins returns stringnpos if not found

srfindpattern
srfindpattern pos

returns the greatest index less than or equal to index pos if given at which
pattern begins returns stringnpos if not found

sfind first ofcharset
sfind first ofcharset pos

returns the least index greater than or equal to index pos if given at which a
character of the indicated string charset is found returns stringnpos if not found

sfind last ofcharset
sfind last ofcharset pos

returns the greatest index less than or equal to index pos if given at which a
character of the indicated string charset is found returns stringnpos if not found

st

returns a concatenation of strings s and t

ssubstrstart

returns the substring from index start through the end

ssubstrstart num

returns the substring from index start continuing num characters

sc str 

returns a cstyle character array representing the same sequence of characters as s

figure 3 nonmutating behaviors supported by the string class in c

syntax

semantics

sindex  newchar

mutates string s by changing the character at the given index to the new character
unpredictable when index is out of range

sappendt

mutates string s by appending the characters of string t

s  t

same as sappendt

sinsertindex t

inserts copy of string t into string s starting at the given index

sinsertindex num c

inserts num copies of character c into string s starting at the given index

serasestart

removes all characters from index start to the end

serasestart num

removes num characters starting at given index

sreplaceindex num t

replace num characters of current string starting at given index with the first num
characters of t

figure 4 mutating behaviors supported by the string class in c

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 13
4 data types and operators

page 13

arrays
the standard structure for storing a mutable sequence of values in python is the list class this
class provides many convenient behaviors for processing the sequence and it provides support for
seemlessly expanding the size of the sequence as needed the standard c libraries which we
will discuss further in section 10 includes a vector class with similar properties
however c also supports a more lowlevel sequence known as an array which has its
origin in the c programming language in fact all of the builtin types for c were defined for
c an array is a contiguous chunk of memory used to store a data sequence what makes an array
different from a structure such as a python list is that the size of the array must be fixed when the
array is constructed and that the contents of the array must have the same data type because the
values are stored directly in the array rather than referentially as with python c arrays are
zeroindexed and rely on the syntax of square brackets for indexing for example if measurements
is a variable representing an array of double values then the expression measurements7 is used to
access the double at index 7 of the sequence that is the eighth entry
finally we note that in the earlier c language which does not have a string class a character
sequence is represented directly as an array of char values in c the string class relies upon an
underlying character array for storage but provides more robust support for convenient operations
that said we note that the c str  method of the string class produces a cstyle character array
for a string instance as is sometimes needed when working with legacy code

42

declarations and initialization

we have emphasized that c is a staticallytyped language and that the type of each variable
must be explicitly declared before use we saw several examples of type declarations in our first
glance of c such as the declaration of local variable r within the gcd function at line 7 of figure 1
int r
it is possible to declare several variables of the same type in a single declaration for example
line 17 of that same program declared the variables a and b within the main function as follows
int ab
a declaration alerts the c compiler as to the type of data that will be stored by the named
variable this allows it to verify subsequent syntax at compiletime knowledge of the data type
also allows the system to reserve the appropriate amount of memory for representing an instance
of the type it is important to note that the system does not necessarily initialize the variable for
primitive types the initial value is indeterminate as it is based upon the previous setting of the
newly reserved bits of memory while it could be initialized using a separate assignment statement
we prefer the use of what we term the constructor syntax when the initial value is known at the
time of the declaration an example of the syntax is
int age42
this declares a new integer variable age yet initializes it to have the indicated value 42 when
using this syntax we can use any valid expression to designate the initial value such as
int agecuryear  birthyear

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 14
4 data types and operators

page 14

we can initialize multiple variables of a common type in a single declarations as in
int age42 zipcode63103

 two new variables

although we noted that declared variables of primitive types are not automatically initialized a declared variable of a class type will be initialized by automatically invoking a form of that
classs constructor using the string class as an example consider the following three declarations
string response
string greetinghello
string rating3 a

 guaranteed to be the empty string 
 initialized to hello
 initialized to aaa

the first version invokes what is known as the default constructor for the class this is a zeroparameter version of the constructor which in the case of strings produces an empty string the second of these lines formally invokes the constructor with a single parameter the character sequence
hello the third example invokes a twoparameter form of the string constructor resulting in
a sequence of n consecutive copies of a given character

arrays
if the desired size of an array is known at compile time it can be declared using a syntax such as
double measurements300
this declares the name measurements to be an array of doubles and causes the system to allocate
memory for storing precisely 300 entries however the values of the individual entries are indeterminate just as when declaring a single double typically the declaration of such an array might
be followed by a loop to initialize the entries to meaningful values yet it is possible to initialize
values of an array as part of the declaration using a syntax such as the following
int daysinmonth   31 28 31 30 31 30 31 31 30 31 30 31
notice that we did not explicitly give the size of the array between the square brackets it will be
implicitly set based on the number of indicated entries if we had given an explicit size for the
array that was larger than the indicated initialization list the beginning of the array will be filled
in using the specified values and the rest is set to zero in the special case of an array of characters
it is possible to initialize the array using a literal as follows
char greeting   hello
as a technicality this becomes an array with size 6 because all cstyle character sequences are
explicitly terminated with an extra zerovalue to designate the end of the sequence
in the case of class types the declaration of an array causes not only the allocation of memory
but the default initialization of each individual entry for example in the following declaration all
entries of the array are guaranteed to be initialized to empty strings
string messages20
thus far our declarations have assumed that the size of an array is known at compile time an
approach for dynamically allocating arrays at runtime will be presented in section 85
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 15
4 data types and operators

page 15

mutability
python and c have very different approaches to the concept of mutability for builtin types
python makes a clear distinction between which are mutable and which are immutable for example it offers a list class for representing mutable sequences and a tuple class for representing
immutable sequences a similar discrepancy exists between the set and frozenset classes
c takes a different approach all types are assumed to be mutable but particular instances
can be designated as immutable by the programmer furthermore the immutability is strictly
enforced by the compiler syntactically the immutability is declared using the keyword const in
specific contexts for example a new variable can be declared as a constant as in
const int age42

 immortality

with this declaration any subsequent attempt to change that value results in a compiletime
error eg age while a programmer may declare a nonconst variable yet leave its value
unchanged the explicit declaration of const in this context allows the compiler to better optimize
the program it also serves as a meaningful label for another programmer who is reading the code
more significant uses of the const keyword arise when describing the treatment of parameters in
function signatures or the effect of method calls upon the state of an object we will discuss those
uses in later sections

43

operators

figure 5 provides a comparison between the operators supported by python and c the operators are largely the same between the two languages but there are some notable discrepancies

numeric types
for numeric values python differentiates between true division ie  integer division
ie  and modular arithmetic ie  as originally discussed in chapter 24 of our book
c supports operators  and  but not  in fact we already saw that symbol used to designate inline comments in c the semantics of the c  operator depends upon the type
of operands when both operands are integral types the result is the integer quotient if one or
both of the operands are floatingpoint types true division is performed to get true division with
integral types one of the operands must be explicitly cast to a float see section 44
both python and c support an operatorwithassignment shorthand for most binary operators as with x  5 as a shorthand for x  x  5 yet c supports an additional  operator
for the common task of incrementing a number by one in fact there are two distinct usages known
as preincrement eg x and postincrement eg x both of these add one to the
value of x but they can be used differently in the context of a larger expression for example
if indexing a sequence the expression groceriesi retrieves the entry based upon the original
index i yet subsequently increments that index in contrast the syntax groceriesi causes the
value of the index to be incremented before accessing the associated entry of the sequence similar
support exists for decrementing a value by one with the  operator the pre and post versions
of these operators are valuable tools for an experienced programmer but their use leads to subtle
code and potential mistakes we recommend that they be used in isolated contexts until mastered

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 16
4 data types and operators

python

page 16

c

description

arithmetic operators



a

a

ab

ab

addition

ab

ab

subtraction

ab

ab

multiplication

a  b
ab



unary negation

exponentiation
ab

a  b
ab

standard division depends on type
integer division

ab

modulus remainder



a

preincrement operator



a

postincrement operator



a

predecrement operator



a

postdecrement operator

boolean operators


and



logical and



or



logical or



not



logical negation



a if cond else b

cond  a  b

conditional expression

comparison operators



ab

ab

less than

a  b

a  b

ab

ab

a  b

a  b

greater than or equal to

a  b

a  b

equal

abc

a  b  b  c

less than or equal to
greater than

chained comparison

bitwise operators
a

a

bitwise complement

ab

ab

bitwise and

ab

ab

bitwise or

ab

ab

bitwise xor

a  b

a  b

bitwise left shift

a  b

a  b

bitwise right shift

figure 5 python and c operators with differences noted by  symbol
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 17
4 data types and operators

page 17

boolean operators
while python uses the words and or and not for the basic logical operators c relies on
the respective symbols   and  although some c compilers now support such named
operators the history of those symbols dates back to the c language it is important not to
confuse the logical operators  and  with the bitwise operators  and 
another pitfall for python programmers converting to c is use of a syntax such as a  b  c
for numeric types in python operators can be chained in such an expression that is true if both
a  b and b  c in c this logic must be expressed as a  b  b  c the more significant
problem is that a  b  c is legal c syntax yet with unexpected semantics this is parsed as
a  b  c the boolean expression a  b evaluates to either false or true however that result
will be coerced into the integer 0 or 1 for the comparison with c the result of the full expression
then depends upon whether c is greater than that 0 or 1 value

class types
by default most operators cannot be used with instances of a class type however c allows
the author of a class to provide specialized semantics for operators when desired as an example
the string class overloads the  operator so that the expression s  t results in a new string that
is the concatenation of existing strings s and t yet the expression s  3 is illegal when s is a string
because no such behavior is defined for the c string class in contrast to python which supports
such an operator for the str class the syntax for defining overloaded operators in c will be
introduced in section 72 when we discuss the robust version of our userdefined point class

44

converting between types

in python we saw several scenarios in which implicit type conversion is performed for example
when performing the addition 15  8 the second operand is coerced into a floatingpoint representation before the addition is performed
there are similar settings in which c implicitly casts a value to another type because of
the static typing additional implicit casting may take place when assigning a value of one type to
a variable of another consider the following example
int a5
double b
b  a

 sets b to 50

the final command causes b to store a floatingpoint representation of the value 50 rather than the
integer representation this is because variable b was explicitly designated as having type double
we can also assign a double value to an int variable but such an implicit cast may cause the loss
of information as any fractional portion of that value will be truncated
int a
double b267
a  b

 sets a to 2

there are other scenarios in which c implicitly converts between types that would not normally
be considered compatible some compilers will issue a warning to draw attention to such cases but
there is no guarantee

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 18
5 control structures

page 18

on a related note there are times when we want to force a type conversion that would not
otherwise be performed such an explicit cast is done using a syntax similar to python where
the name of the target type is used as if a function
int a4 b3
double c
c  ab
c  doubleab

 sets c to 10
 sets c to 133

the first assignment to c results in 10 because the coercion to a double is not performed until
after the integer division ab is performed in the second example the explicit conversion of as
value to a double causes a true division to be performed with b implicitly coerced however we
cannot use this casting syntax to perform all type conversions for example we cannot safely mimic
pythons approach for converting a number to a string as with str17 or to convert a string to
the corresponding number as with int17 unfortunately conversions back and forth between
strings require more advanced techniques we will discuss one such approach in section 66 using
an object known as a stringstream

5

control structures

51

while loops

we demonstrated an example of a while loop as part of our first example in section 3 the logic is
similar to python but with superficial differences in syntax most notably parentheses are required
around the boolean condition in c in that first example curly braces were used to delimit the
commands that comprise the body of the loop technically those braces are only needed when the
body uses two or more distinct statements in the absence of braces the next single command is
assumed to be the body
c also supports a dowhile syntax that can be a convenient remedy to the loopandahalf
problem as seen with while loops on page 165 of our book here is a similar c codefragment
for requesting a number between 1 and 10 repeating until receiving a valid choice
int number
do 
cout  enter a number from 1 to 10 
cin  number
 while number  1  number  10
please note that we have not properly handled the exceptional case when a noninteger is entered

52

conditionals

a basic if statement is quite similar in style again requiring parentheses around the boolean condition and curly braces around a compound body as a simple example here is a construct to set
a number to its absolute value
if x  0
x  x
notice that we did not need braces for a body with one command
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 19
5 control structures

page 19

c does not use the keyword elif for nesting conditionals but it is possible to nest a new if
statement within the body of an else clause furthermore a conditional construct is treated syntactically as a single command so nesting does not require excessive braces our first example of a
nested conditional in python was given on page 144 of chapter 442 of our book that code could
be written in c to mimic pythons indentation as follows assuming groceries is an adequate
container
if grocerieslength   15
cout  go to the grocery store  endl
else if groceriescontainsmilk
cout  go to the convenience store  endl

53

nonboolean expressions as conditions

on page 142 of our book we demonstrate ways in which nonboolean data types can be used in
place of a boolean expression for a conditional statement c also provides support for coercing
certain nonboolean data types in certain contexts with builtin numeric types c treatment is
similar to pythons in that a zero value is coerced as false and any nonzero value as true so we
might write the following code assuming that mistakecount is declared as an integer
if mistakecount
 ie if mistakecount  0
cout  there were   mistakecount   errors  endl
for class types c allows the author of the class to determine whether values of that type
can be coerced into a bool or any other primitive type for that matter so it would be possible
to define a container type that mimics pythons treatment with empty containers treated as false
and nonempty containers treated as true we should note however that neither the standard
container classes or strings support such coercion in c
the implicit conversion from numbers to booleans in c together with the treatment of an
assignment statement is to blame for a common pitfall exemplified by the falling errant code
double gpa
cout  enter your gpa 
cin  gpa
if gpa  40
cout  wow  endl
do you see the problem the mistake is the use of the assignment operator gpa  40 rather
than the equivalence operator gpa  40 the above code is syntactically valid in c but
it does not behave as you might expect rather than comparing the inputted value of gpa that
statement reassigns variable gpa the value of 40 essentially overwriting the response given by the
user furthermore c considers the value of the assignment expression in the larger context to
be the newly assigned value which itself is implicitly coerced to a boolean value thus no matter
what the user enters the gpa is reset to 40 coerced to true and the conditional body is entered
it is natural to ask why the designers of c and c allow such a behavior one reason is to
support the chaining of assignments using the following syntax
a  b  40

 assuming both a and b were previously declared

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 20
5 control structures

page 20

c treats this as two separate operations evaluated from righttoleft as if written as
a  b  40
so b is assigned the value 40 and then the new value of b serves as the result of the parenthesized
subexpression this allows a to be subsequently assigned
to avoid such a common pitfall python disallows use of an assignment statement in the context
of a conditional code such as if gpa  40 results in a syntax error python support the chaining
syntax a  b  40 using a different mechanism just as it does with inequalities like a  b  c

54

for loops

c supports a for loop but with very different semantics than pythons the style dates back to
its existence in c to provide a more legible form of the typical indexbased loop pattern described
in chapter 411 of our book an example of a loop used to count downward from 10 to 1 is as
follows
for int count  10 count  0 count
cout  count  endl
cout  blastoff  endl
within the parentheses of the for loop are three distinct components each separated by a semicolon
the first is an initialization step that is performed once before the loop begins the second portion
is a loop condition that is treated just as a loop condition for a while loop the condition is tested
before each iteration with the loop continuing while true finally we give an update statement that
is performed automatically at the end of each completed iteration the for loop syntax is just a
convenient alternative to a while loop that better highlights the logic in some cases the previous
example is essentially identical in behavior to the following version
int count  10
while count  0 
cout  count  endl
count

cout  blastoff  endl

 initialization step
 loop condition
 update statement

the for loop is far more general it is possible to express multiple initialization or update steps
in a for loop this is done by using commas to separate the individual statements as opposed to
the semicolon that delimits the three different components of the syntax for example the sum
of the values from 1 to 10 could be computed by maintaining two different variables as follows
int count total
for count  1 total  0 count  10 count
total  count
it is also possible to omit the initialization or update steps so long as the semicolons remain as
separators the loop condition is the only strictly required component

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 21
6 input and output

55

page 21

defining a function

our initial c example from section 3 includes the definition of a gcd function we emphasized
the need to explicitly designate the type of each individual parameter as well as the return type
together with the name of the function this information is collectively known as the signature
of the function for example the signature in our original example was int gcdint u int v this
signature serves as a guide for a potential caller of the function and it provides sufficient information
for the compiler to enforce proper usage
some functions do not require parameters and some do not provide a return value without
any parameters a function definition still requires opening and closing parentheses after the function name functions that do not provide a return value must still designate so by using a special
keyword void in place of a return type as an example the following function prints a countdown
from 10 to 1 it does not accept any parameters nor return any value
void countdown  
for int count  10 count  0 count
cout  count  endl

we used an alternative version of this function in chapter 522 of our book to demonstrate the
use of optional parameters in python the same technique can be used in c with the syntax
void countdownint start10 int end1 
for int count  start count  end count
cout  count  endl

this signature will support a calling syntax such as countdown52 to go from 5 to 2 countdown8
to go from 8 to 1 or countdown  to go from 10 to 1 there is a technical distinction between python
and c regarding the instantiation of a default parameter in python the default parameter
value is instantiated once upon declaration of the function and then used when the function is
called this is occasionally significant especially when using mutable objects as default values in
c default parameter values are reinstantiated as needed with each call to the function

6

input and output

input and output can be associated with a variety of sources within a computer program for
example input can come from the users keyboard can be read from a file or transmitted through
a network in similar regard output can be displayed on the users screen written to a file or
transmitted through a network to unify the treatment of input and output c relies on a
framework of classes to support an abstraction known as a stream we insert data into an
output stream to send it elsewhere or extract data from an input stream to read it a stream that
provides us with input is represented using the istream class and a stream that we use to send
output elsewhere is represented using the ostream class some streams can serve as both input
and output iostream in this section we provide an overview of the most commonly used stream
classes a summary of those is given in figure 6

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 22
6 input and output

class

page 22

purpose

library

istream

parent class for all input streams

iostream

ostream

parent class for all output streams

iostream

iostream

parent class for streams that can process input and output

iostream

ifstream

input file stream

fstream

ofstream

output file stream

fstream

fstream

inputoutput file stream

fstream

istringstream

string stream for input

sstream

ostringstream

string stream for output

sstream

stringstream

string stream for input and output

sstream

figure 6 various input and output stream classes

61

necessary libraries

technically streams are not automatically available in c rather they are included from one
of the standard libraries a c library serves a similar purpose to a python module we will
discuss them more fully in section 12 in our initial example we loaded the definitions as follows
include iostream
using namespace std
the first of these statements imports the iostream library short for inputoutput stream the
second brings the definitions into our default namespace in addition to the basic class definitions
this library defines two special instances for handling input to and from the standard console cout
short for console output is an ostream instance used to print messages to the user and cin
short for console input is an istream instance that reads input from the keyboard

62

console output

output streams support the  operator to insert data into the stream as in cout  hello
the  symbol subliminally suggests the flow of data as we send the characters of hello into the
stream as is the case with print in python c will attempt to create a text representation for any
nonstring data inserted into the output stream multiple items can be inserted into the stream by
repeated use of the operator as in cout  hello  person   how are you notice
that we explicitly insert spaces when desired in contrast to use of pythons print command we
must also explicitly output a newline character when desired although we could directly embed
the escape character n within a string c offers the more portable definition of a special object
endl that produces a newline character when inserted into the stream to demonstrate typical
usage patterns figure 7 provides several sidebyside examples in python and c

63

formatted output

in python string formatting can be used to generate output in a convenient form as in
print s ranked d of d teams  team rank total

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 23
6 input and output

page 23

python
1
2
3
4
5
6
7
8

print
print
print
print
print
print
print
print

hello
 blank line
hello first
first last
total
strtotal  
wait
done

 automatic space
 no space
 space no newline

c
1
2
3
4
5
6
7
8

cout
cout
cout
cout
cout
cout
cout
cout










hello  endl
endl
 blank line
hello   first  endl
first     last  endl
total  endl
total    endl
wait 
 no newline
done  endl

figure 7 demonstration of console output in python and c we assume that variables first
and last have previously been defined as strings and that total is an integer
the use of the  sign in this context is designed to mimic a longstanding routine named printf
which is part of the c programming language since c is a direct descendant of c that function
is available through a library but it is not the recommended approach for c because it does
not inherently support nonprimitive data types eg the c string class instead formatted
output can be generated through the output stream since data types are automatically converted
to strings the above example can be written in c as
cout  team   ranked   rank   of   total   teams  endl
more effort is needed to control other aspects of the formatting such as the precision for floatingpoint values as an example assume that the variable pi holds the value 314159265 in python
the expression pi is 3f pi produces the result pi is 3142 the closest equivalent to
the display of variable pi in c might be accomplished as
cout  pi is   fixed  setprecision3  pi  endl
this command would result in the output pi is 3142 the objects fixed and setprecision3 are
known as manipulators and must be included from the iomanip library when inserted into
the output stream with  they affect the format for subsequent values in this particular case
the fixed manipulator says to print floatingpoint numbers with trailing decimal digits even when
zero and not to use scientific notation even for very large or very small values the setprecision3
manipulator specifies the number of digits beyond the decimal point to be used in the fixed format
the minimum width of displayed values and the justification within that width can be controlled by additional manipulators as an example we might print an entry on a receipt as
cout  setw10  item     setw5  quantity  endl
this is equivalent to the python command print 10s 5d item quantity if we execute this
command once with values pencil and 50 and then with values pen and 100 the output is aligned as
pencil
pen

50
100

as is the case with python data in a fixedwidth field will be rightjustified by default we can

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 24
6 input and output

page 24

switch to leftjustification in c by inserting the manipulator left into the stream for example
if we repeat the previous exercise using the command
cout  left  setw10  item    right  setw5  quantity  endl
we get a result of
pencil
pen

50
100

it is worth noting that the c manipulators are different than pythons formatting tools
in that most of the manipulators we have demonstrated change the state of the output stream
object for example once the fixed manipulator has been inserted into a stream all subsequent
numbers for that stream will be displayed in that format unless a conflicting manipulator such as
scientific is subsequently inserted in our most recent example notice that we explicitly inserted
the manipulator right before outputting quantity to reestablish rightjustification otherwise the
formatting would still be affected by the earlier insertion of left however there are some exceptions
to this rule the setw manipulator demonstrated above only affects the next piece of displayed
output in our example the insertion of setw10 affected the display of the string item yet it did
not dictate a minimum width for the subsequent string  

64

console input

in python input from the console is typically read using the raw input function as in
person  raw inputwhat is your name
in c keyboard input is managed through an input stream named cin just as console output
is managed by cout the behavior of the python example can be replicated with a c function
named getline its calling syntax appears as
string person
cout  what is your name 
getlinecin person

 prompts the user without a newline
 stores result directly in variable person

both pythons raw input and cs getline read and remove all characters from the input stream
up to and including the next newline yet with the newline itself omitted from the resulting string
however direct use of getline is atypical in c instead of reading a line at a time programmers can use the  operator for extracting individual pieces of formatted data from an input
stream as an example consider the task of reading a single integer from the user in python we
have to first get the raw string and separately compute the integer that those characters represent
consider for example number  intraw inputenter a number from 1 to 10  in c
the corresponding code fragment might appear as follows
int number
cout  enter a number from 1 to 10   prompt without newline
cin  number
 read an integer from the user
the  operator extracts data from the stream and stores it in the indicated variable the static
typing of c is advantageous in this context because number was already designated as an
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 25
6 input and output

page 25

integer the input characters are automatically converted to the corresponding integer value
much as the  operator can be chained in order to insert several pieces of data into an output
stream in a single command it is possible to chain the  operator can be chained to read in several pieces of data for example here is a code fragment that asks the user to enter two numbers
and computes their sum
int a b
cout  enter two integers 
cin  a  b
cout  their sum is   a  b    endl
the third line has the effect of inputting two separate integers the first of which is stored in
variable a and the second in b formally the  operator works by skipping any whitespaces
eg spaces or newlines that reside at the front of the stream and then interpreting the first
nonwhitespace token as an integer the second occurrence of the  operator on that line causes
intermediate whitespace to be removed from the stream and the next token to be interpreted as an
integer any subsequent characters including further whitespace remain on the stream
when using the stream operator it does not matter whether the user enters the integers on
the same line or different lines as intermediate newlines and spaces are treated similarly it also
does not matter whether the programmer uses the chained syntax cin  a  b or two separate
commands cin  a followed by cin  b both forms are valid regardless of the users spacing
note that this management of input streams is quite different from our usage of the raw input
command in python which reads a single line if we expect the user to enter two integers on a
single line of input in python we have to read the line then split it into two pieces based on white
space and then attempt to convert each of those pieces to the corresponding integer a python
version of such a program is given as the solution to practice 231 in the book
to emphasize the different treatment of whitespace we reconsider our initial example of querying a persons name our original c solution used the getline function to more accurately
mirror pythons style as an alternative we could write the c code as
string person
cout  what is your name 
cin  person

 prompt the user without a newline
 input the response

yet this code does not strictly have the same behavior to highlight the difference consider the
following user session
what is your name  guido van rossum
after executing the c code the variable person will be assigned the string guido while the
subsequent characters  van rossumn remain on the stream as it extracted starting with the
first nonwhitespace character and stopping prior to the next subsequent whitespace if the use of
newlines is significant to the context a programmer should use a function like getline however
careful consideration of the whitespace treatment is important when interspersing calls to getline
with use of the  operator a call to getline removes the ending newline from the stream but
use of the extraction operator reads a token while leaving subsequent whitespace on the stream
consider the following code fragment

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 26
6 input and output

page 26

int age
string food
cout  how old are you 
cin  age
cout  what would you like to eat 
getlinecin food
a typical user session might proceed as follows
how old are you  42
what would you like to eat  pepperoni pizza
the problem is that after executing the above code the variable food will be set to the empty
string  the first extraction properly read the age as 42 but the newline character that the user
entered after those characters remains on the stream even though the user had entered additional
input the call to getline first encounters an apparent empty line because of the remaining newline
from the first response this can be remedied by intentionally reading the blank line before reading
the food a more robust approach relies on use of an ignore function supported by input streams
another approach for handling linebased input is to always rely on getline to read a single line into
a string and then to use a class named stringstream that supports extracting formatted data from
a string we will discuss the stringstream class in section 66
finally we address the issue of what happens when something goes wrong while attempting to
read input for example the user might enter the characters hello when an integer was expected
other unexpected situations may cause failure of the input stream such as it being closed when a
user types cntrd into the console in python such errors result in a formal exception being thrown
for example a valueerror is reported when trying to get an integer value from an improperly
formatted string and an ioerror is reported if the raw input call fails in c an attempt at
extracting data from a stream does not throw an exception by default instead the flow of control
continues but with the value of the inputted variable left indeterminate to support more robust
behaviors the streams have methods that allow a programmer to check various aspects of their
state for example if a user types nonnumeric characters when an integer is expected the streams
fail bit is set to true internally and can be tested with a call to cinfail  that bit remains set
until explicitly cleared by the programmer other state bits can be queried to determine whether
the end of file has been reached on a stream or if some other bad state has been reached
page 182 of our book gives a more robust python fragment for reading a valid integer from 1 to
10 for comparison figure 8 of this document presents a similar code fragment in c

65

file streams

c supports additional stream classes for managing input and output involving files specifically
the fstream library defines the ifstream class for reading input from a file the ofstream class for
writing output to a file and an fstream class that is capable of simultaneously managing input and
output for a given file
we begin with an example using an ifstream instance if the name of an existing file is known
in advance an input stream can be declared as
ifstream mydatascorestxt

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 27
6 input and output

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20

page 27

number  0
while number  1  number  10 
cout  enter a number from 1 to 10 
cin  number
if cinfail  
cout  that is not a valid integer  endl
cinclear 
 clear the failed state
cinignorestdnumeric limitsintmax  n
 remove errant characters from line
 else if cineof  
cout  reached the end of the input stream  endl
cout  we will choose for you  endl
number  7
 else if cinbad  
cout  the input stream had fatal failure  endl
cout  we will choose for you  endl
number  7
 else if number  1  number  10 
cout  your number must be from 1 to 10  endl


figure 8 robust errorchecking with input streams
if the filename is not known in advance the stream can be initially declared without a filename
and opened as a later operation the open method accepts the filename as a parameter but for
historical reasons requires that the name be expressed as a cstyle string here is an example usage
ifstream mydata
string filename
cout  what file 
cin  filename
mydataopenfilenamec str 

 parameter to open must be a cstyle string

the same techniques can be used with an ofstream instance for writing to a file by default
opening an ofstream causes the target file to be overwritten by a new file just as with pythons
openscorestxt w if you want to append to the end of an existing file as with pythons
openscorestxt a the c command is
ofstream datastreamscorestxt iosapp
the more general fstream class can be used to simultaneously manage input and output from
the same file although coordinating such manipulations takes more care

66

string streams

we have seen how cin and cout manage the console and how the file streams are used to manage
files all of the stream operators offer convenient support for reading or writing formatted data
as an example if we have an integer age the command cout  age converts the integer into the
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 28
7 classes in c

page 28

corresponding characters used to display that number eg 42 but what if we want to compute
the string representation of an integer not for immediate output but perhaps to save in a string
variable in python the syntax displayedage  strage produces such a string
we avoided this issue at the end of section 4 because the conversion is not quite as direct in
c instead we can use the stringstream class included from the sstream library this class
allows us to use the stream operators to insert formatted data into a string or to extract formatted
data from that string for example here is code that produces a string based upon an integer value
int age42
string displayedage
stringstream ss
ss  age
 insert the integer representation into the stream
ss  displayedage  extract the resulting string from the stream
string streams can also be used to convert in the other direction starting with a string and parsing
it to extract pieces of data for example in section 64 we discussed differences between tokenized
input in c versus pythons style of using raw input to read a line and then subsequently splitting
the tokens on that line in c we can emulate such a style by using getline to read a single line
as a string and then using a stringstream to manage subsequent extractions of formatted data

7

classes in c

classes provide the same abstraction for storing and manipulating information in c as they
do in python in section 71 we discuss classes from the perspective of a user of a class with
rather similar syntax between python and c other than the need for a clear type declaration
in c in section 72 we introduce the syntax for defining classes in c we discuss the
additional complexities that arise when defining a class in c due to the additional burden of
type declarations and other such specifications that assist in more rigorous compiletime checking

71

using instances of a class

thus far most of our examples have used primitive data types eg int double however string
is a class type as are the various forms of streams from the previous section in c when a
variable of a class type is declared an instance of that class is automatically constructed two
examples of such a declaration are the following
string s
string greetinghello

 relies on default constructor without parameters
 explicit parameter sent to the constructor

in the first declaration a new string instance is created using the default constructor of the class
that is a constructor that accepts zero parameters in the case of strings the default constructor
produces the empty string the second syntax invokes a form of the string class constructor that
accepts a parameter to designate the initial contents of the new string
as an aside we wish to warn against a few potential mistakes in the declaration syntax first
when relying upon the default constructor we did not use empty parentheses had we used parentheses it would have looked like the following
string s 

 warning a function declaration

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 29
7 classes in c

page 29

although the intent may be to send zero parameters to the constructor the c parser deems
this syntax as the signature for a function named s taking zero parameters and returning a string
that is after all how such a functions signature would appear as a second example we wish to
emphasize that when parameters are specified in a declaration they are included after the variable
name rather than after the class name compare the following illegal syntax with the original
correct syntax
stringhello greeting

 parameters in wrong place

with that said there is a scenario in which the parameters to a constructor appear after the
class name this happens when a programmer wishes to construct an unnamed instance as part of
a larger expression such as cout  string20  we will see another such use in the coming
section involving the robust version of a point class a line of that code will appear as follows
double mag  distance point  

 measure distance to the origin

the syntax point  in this expression causes the construction of a new point instance based on the
default constructor and in this context the explicit parentheses are necessary
once an instance of a class has been constructed c uses typical objectoriented syntax such
as greetingreplace1 4 ey to call the replace method on the string identified as greeting

72

defining a class

to demonstrate the syntax for defining a c class we revisit several python examples from
chapter 6 of our book we begin with the simple version of the point class as given in figure 63
on page 206 the corresponding c version of that class is given in figure 9 of this document
there are several important aspects to discuss in comparing cs syntax to pythons

explicit declaration of data members
the issue of static typing arises prominently in a class definition as all data members must be
explicitly declared recall that in python attributes of a class were simply introduced by assignment statements within the body of the constructor in our c example we explicitly declare
the two data members at lines 3 and 4

constructor
line 7 of our code is the constructor although the syntax requires some explanation the line
begins with the name of the class itself ie point followed by parentheses the constructor is a
function with this particular example accepting zero parameters however unlike other functions
there is no designated return value in the signature not even void
the next piece of syntax is the colon followed by x0 y0 this is what is known as an
initializer list in c it is the preferred way to establish initial values for the attributes we
are not allowed to express initial values on lines 3 and 4 finally we see the syntax   this is
technically the body of the constructor some classes use the constructor body to perform more
intricate initializations in this case having already initialized the two variables there is nothing
else for us to do so the   serves syntactically as a placeholder for the function body somewhat
like pass in python

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 30
7 classes in c

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25

page 30

class point 
private
double x
double y

 explicit declaration of data members

public
point   x0 y0  

 constructor

double getx  const 
return x


 accessor

void setxdouble val 
x  val


 mutator

double gety  const 
return y


 accessor

void setydouble val 
y  val


 mutator



 end of point class semicolon is required
figure 9 implementation of a simple point class

implicit selfreference
a careful reader will have already noticed another major distinction between the class definition in
c and the same class in python the self reference does not appear as a formal parameter nor is
it used when accessing members of the instance remember that we have explicitly declared x and
y to be attributes of a point because of this the compiler recognizes those identifiers when used
within the body of our methods for example at line 10 for those who miss the selfreference it
is implicitly available in c yet with the name this it can be useful for example when passing
the object as a parameter to an outside function technically this is a pointer variable a concept
that will be introduced in section 83

access control
another distinction in c is the use of the terms public and private within the class definition
these relate to the issue of encapsulation with python we addressed this issue in chapter 76 of
our book differentiating at the time between what we considered public versus private aspects
of a class design public aspects are those that we expect other programmers to rely upon while
private ones are considered to be internal implementation details that are subject to change yet
python does not strictly enforce this designation instead we relied upon naming conventions

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 31
7 classes in c

page 31

using identifiers that start with an underscore eg x to infer privacy
in c these designators serve to declare the desired access control for the various members
both data members and functions the use of the term private at line 2 affects the declarations
at lines 3 and 4 while the term public at line 6 effects the subsequent declarations the compiler
enforces these designations within the rest of the project ensuring that the private members are
not directly accessed by any code other than our class definition

designating accessors versus mutators
in our python book we used the notion of an accessor as a method that cannot alter the state of
an object and a mutator as a method that might alter the state this distinction is formalized
in c by explicitly placing the keyword const for accessors at the end of the function signature
but before the body in our example we see this term used in the signature of getx at line 9 and
again for gety at line 17 we intentionally omit such a declaration for the mutators setx and sety
as with access control these const declarations are subsequently enforced by the compiler if
we declare a method as const yet then try to take an action that risks altering any of the attributes
this causes a compiletime error furthermore if a caller has an object that had been designated
as immutable the only methods that can be invoked upon that object are ones that come with the
const guarantee

a robust point class
to present some additional lessons about class definitions in c we provide a more robust
implementation of a point class modeled upon the python version from figure 64 on page 213 of
our book our c version is shown in figures 10 and 11 of this document
our first lesson involves the constructor in python we declared a constructor with the signature
def init self initialx0 initialy0 this provided flexibility allowing a caller to set initial
coordinates for the point if desired but to use the origin as a default the c version of this
constructor is given at line 7
in our first version of the class we emphasized that data members of the class can be accessed
without explicitly using a selfreference for example using a syntax like x rather than pythons
self x the same convention is used when the body of one member function invokes another
for example our implementation of the normalize method relies on a call to the distance method
at line 26 and the scale method at line 28 those calls are implicitly invoked on the same point
instance upon which normalize has been invoked in contrast the use of the constructor point  at
line 26 instantiates a new default point as a parameter to the distance function
lines 3133 are used to support the syntax p  q for the addition of two points this behavior is
akin to the add method in python yet in c the semantics are defined using operator as the
name of the method in this context the lefthand operand p serves as the implicit instance upon
which the operator method is invoked while q appears as an explicit parameter in the signature
the const declaration that we make at line 31 designates that the state of p is unaffected by the
behavior q is unaffected as well but we delay discussion of that issue until section 82
lines 3541 support two different notions of multiplication multiplying a given point by a
numeric constant and computing the dot product of two points our original python implementation accomplished this with a single function definition that accepted one parameter internally
it performed dynamic typechecking of that parameter and determined the appropriate behavior
depending on whether the second operand was a point or a number in c we provide two
different implementations the first accepts a double and returns a new point the second accepts

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 32
7 classes in c

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42

page 32

class point 
private
double x
double y
public
pointdouble initialx00 double initialy00  xinitialx yinitialy  
double getx  const  return x 
void setxdouble val  x  val 
double gety  const  return y 
void setydouble val  y  val 






same
same
same
same

as
as
as
as

simple
simple
simple
simple

point
point
point
point

class
class
class
class

void scaledouble factor 
x  factor
y  factor

double distancepoint other const 
double dx  x  other x
double dy  y  other y
return sqrtdx  dx  dy  dy

void normalize  
double mag  distance point  
if mag  0
scale1mag


 sqrt imported from cmath library

 measure distance to the origin

point operatorpoint other const 
return point x  other x y  other y

point operatordouble factor const 
return point x  factor y  factor

double operatorpoint other const 
return x  other x  y  other y

  end of point class semicolon is required
figure 10 implementation of a robust point class

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 33
7 classes in c

43
44
45
46
47
48
49
50
51

page 33

 freestanding operator definitions outside the formal point class definition
point operatordouble factor point p 
return p  factor
 invoke existing form with point as left operand

ostream operatorostream out point p 
out    pgetx     pgety   
return out


 display using form xy

figure 11 supplemental operator definitions involving point instances
a point and coincidentally returns a double providing two separate declarations of a method is
termed overloading the signature since all data is explicitly typed c can determine which
of the two forms to invoke at compiletime based on the actual parameters
line 42 ends our formal point class declaration however we provide two supporting definitions
following that line the first of those is used to support a syntax such as 325  p the earlier
definition of operator from lines 3537 supports the  operator when a point instance is the lefthand operand eg p  325 c does not allow the class definition of the righthand operand
to directly impact the behavior yet if the lefthand operands type does not provide an adequate
definition as with type double in the expression 325  p c looks for a freestanding operator
function with a matching signature so at lines 4446 we provide a definition for how  should
behave when the first operand is a double and the second is a point notice that both operands
appear as formal parameters in this signature since we are no longer within the context of a class
definition the body of our method uses the same simple trick as in our python implementation
commuting the order so that the point becomes the lefthand operand thereby invoking our
previously defined version as an aside notice that we did not have to have such an additional
definition for operator since both operands and thus the lefthand one are point instances for
addition
finally lines 4851 are used to produce a text representation of a point when inserted into an
output stream a typical syntax for such a behavior is cout  p again we define this behavior
outside of the context of the point class because the lefthand operand is the output stream and
because we are not the authors of the ostream class in our implementation line 49 inserts our
desired output representation into the given output stream we use the formal parameter out
rather than cout so that a user can apply this behavior to any output stream instance the
declared return type on line 48 and the return statement at line 50 are technically required to
allow for multiple  operations to be chained in a single expression for example the syntax
cout  p   is good is evaluated as cout  p   is good with the result of the
first evaluation being an output stream used in the second operation the use of the  symbol
twice on line 48 for both the return type and the first parameter type is a technicality that we
will address in section 82

73

inheritance

in chapter 9 of our book we provided several examples of the use of inheritance in python we
will show two of those examples translated to c first we define a deluxetv class modeled
closely after the version in figure 92 of the book which used a sortedset although we omit the
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 34
7 classes in c

page 34

1 class deluxetv  public television 
2
protected
3
setint favorites
4
5
public
6
deluxetv  
7
television 
 parent constructor
8
favorites 
 empty set by default
9

10
11
void addtofavorites   if  poweron favoritesinsert channel 
12
13
void removefromfavorites   if  poweron favoriteserase channel 
14
15
int jumptofavorite  
16
if  poweron  favoritessize   0 
17
setintiterator result  favoritesupper bound channel
18
if result  favoritesend 
19
result  favoritesbegin 
 wrap around to smallest channel
20
setchannelresult
21

22
return channel
23

24   end of deluxetv
figure 12 implementing a deluxetv class through inheritance
presumed definition for a basic television class our complete code for the deluxetv class is given
in figure 12 the use of inheritance is originally indicated at line 1 by following the declaration
of the new class with a colon and then the expression public television with that designation2 
our deluxetv class immediate inherits all attributes eg poweron channel and all methods eg
setchannel from the parent what remains is for us to define additional attributes or to provide
new or updated implementations for methods that we want supported
at line 3 we declare a new attribute to manage the set3 of favorite channel numbers we wish
to draw particular attention to the use of the word protected at line 2 until now we have used
two forms of access control public and private members that are public can be accessed by code
outside of the class definition while members that are private can only be accessed from within the
original class definition the purpose of privacy is to encapsulate internal implementation details
that should not be relied upon by others yet with the use of inheritance there is need for a third
level of access when one class inherits from another the question arises as to whether code for
the child class should have access to members inherited from the parent this is determined by the
access control designated by the parent a child class cannot directly access any members declared
as private by the parent however the child is granted access to members designated as protected
by the parent
2
3

for the sake of simplicity we will not discuss the precise significance of the term public on line 1
we will discuss the set class and other containers in section 10

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 35
7 classes in c

page 35

in this particular setting the important point is not actually our use of protected at line 2
what matters to us is how the original attributes of the television class were defined for our
deluxetv code to work it must be that television attributes were originally declared as
protected
bool poweron
int channel

if those had been declared as private we would not have the necessary access to implement our
deluxetv the original designer of the television may not have known that we would come along
and want to inherit from it but an experienced c programmer will consider this possibility when
designing a class in our deluxetv definition the declaration of attribute favorites as protected
is not for our own benefit but to leave open the possibility that someone else may one day want
to design a superdeluxetv that improves upon our model as an alternative to protected data a
parent can provide protected member functions to encapsulate the private state
the second aspect of our example we wish to discuss is the definition of our constructor at
lines 69 in our python version the new constructor begins with an explicit call to the parent
constructor using the syntax television init self that was used to establish the default settings
for all of the inherited attributes in c we can invoke the parent constructor as part of the
initializer list using the syntax television  at line 7 this calls the parent constructor without
sending any explicit parameters to be honest in this particular example line 7 is superfluous if
we do not explicitly call the parent constructor c will do so implicitly however an explicit call
is necessary when parameters are to be sent to the parent constructor as in our second example
in this example our default initialization of favorites at line 8 is also superfluous
lines 1123 of our deluxetv code provides three new behaviors the precise details of those
methods depend on knowledge of the set class as such we will revisit some of this code in section 10
our purpose for the moment is to demonstrate the use of inheritance we draw attention to the
fact that we are able to access the inherited attributes poweron and channel as well as our new
attribute favorites when implementing the methods we also call the inherited method setchannel

a square class
as a second example of inheritance figure 13 provides a c rendition of our original square class
from chapter 942 of our book the square inherits from a presumed rectangle class we do not
introduce any new attributes for this class so our only responsibility for the constructor is to ensure
that the inherited attributes are properly initialized to this end we invoke the parent constructor
at line 4 in this case we need the explicit call in order to pass the appropriate dimensions and
center had we not done so an implicit call would have been made to the default version of the
rectangle constructor leading to incorrect semantics for our square
the remainder of the definition is meant to provide new getsize and setsize methods while
also overriding the existing setheight and setwidth methods so that a change to either dimension
affects both we use the same approach as our python version we override the existing methods
at lines 7 and 8 changing their behaviors to call our new setsize method our setsize method
then relies upon the parent versions of the overridden setwidth and setheight methods to enact the
individual changes to those values the expression rectangle before the method names at lines 11
and 12 is a scope resolution indicating our desire to invoke the definitions of those behaviors
from the parent rectangle class rather than the corresponding methods of the square class

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 36
8 object models and memory management

page 36

1 class square  public rectangle 
2 public
3
squaredouble size10 point centerpoint  
4
rectanglesize size center
 parent constructor
5

6
7
void setheightdouble h  setsizeh 
8
void setwidthdouble w  setsizew 
9
10
void setsizedouble size 
11
rectanglesetwidthsize
 make sure to invoke parent version
12
rectanglesetheightsize
 make sure to invoke parent version
13

14
15
double getsize  const  return getwidth  
16   end of square
figure 13 implementing a square class based upon a rectangle

8

object models and memory management

python supports a consistent model in which all identifiers are inherently references to underlying
objects use of the assignment operator as in a  b causes identifier a to be reassigned to the same
underlying object referenced by identifier b these semantics are consistently applied to all types of
objects the assignment semantics also apply to the passing of information to and from a function
as described in chapter 1031 of our book upon invocation the formal parameters are assigned
respectively to the actual parameters indicated by a caller the return value is communicated in
a similar fashion as a simple example assume that we define the following python function for
determining whether a given point is equivalent to the origin
def isoriginpt
return ptgetx   0 and ptgety   0
now assume that the caller invokes this function as isoriginbldg where bldg is an identifier that
references a point instance figure 14 diagrams the underlying configuration this scenario is
the precise result of the system performing an implicit assignment pt  bldg setting the formal
parameter to the actual parameter

bldg

pt

point
x  90233
y  38636

figure 14 an example of parameter passing in python
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 37
8 object models and memory management

page 37

c provides more finetuned control than python allowing the programmer a choice between
three different semantic models for storing and passing information in this section we examine
the correspondence between identifiers and underlying values in c

81

value variables

the most commonly used model in c is that of a value variable declarations such as
point a
point b57
cause the system to reserve memory for storing newly constructed points because all data members
for a point are explicitly declared in the class definition the system can determine precisely how
much memory is required for each instance the translation from a name to a particular instance
is handled at compiletime providing greater runtime efficiency than pythons runtime mapping
to portray the semantics of a value variable we prefer a diagram in the style of figure 15
without any independent concept of a reference the assignment semantics for a value variable
is very different from pythons the command a  b assigns point a the value currently held by
point b as diagrammed in figure 16 notice that names a and b still represent two distinct points
the semantics of value variables is manifested as well in the passing of information to and from
a function consider the following c analog to our earlier python example
bool isoriginpoint pt 
return ptgetx   0  ptgety   0

when a caller invokes the function as isoriginbldg the formal parameter point pt is implicitly
initialized as if using the copy constructor syntax
point ptbldg
note that the formal parameter pt does not become an alias for the actual parameter it is a newly
allocated point instance with state initialized to match that of the actual parameter bldg figure 17
portrays this scenario as a result changes made to the parameter from within the function body
have no lasting effect on the callers object this style of parameter passing is generally termed
passbyvalue as originally discussed on page 351 of our book
a  point

b  point

x  00
y  00

x  50
y  70

figure 15 the declaration of two separate value variables
a  point

b  point

x  50
y  70

x  50
y  70

figure 16 the effect of an assignment a  b upon value variables

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 38
8 object models and memory management

page 38

bldg  point

pt  point

x  90233
y  38636

x  90233
y  38636

figure 17 an example of passing by value in c
c
a  point

b  point

x  00
y  00

x  50
y  70

figure 18 the name c is an example of a reference variable in c

82

reference variables

a second model for a c variable is commonly termed a reference variable it is declared as
point ca  reference variable
syntactically the distinguishing feature is the use of the ampersand this designates c as a new
name but it is not a new point instead it becomes an alias for the existing point a we choose
to diagram such a situation as in figure 18
this is closer to the spirit of pythons model but still not quite the same a c reference
variable must be bound to an existing instance upon declaration it cannot be a reference to nothing
as is possible in python with the none value furthermore the reference variables binding is
static in c once declared that name can no longer be reassociated with some other object
the name c becomes a true alias for the name a the assignment c  b does not rebind the name c
this changes the value of c also known as a
reference variables are rarely used as demonstrated above because there is little need in a
local context for a second name for the same object yet the reference variable semantics becomes
extremely important in the context of functions we can use a passbyreference semantics by
using the ampersand in the declaration of a formal parameter as in the following revision of isorigin
bool isoriginpoint pt 
return ptgetx   0  ptgety   0

this leads to a model similar to python in that the formal parameter becomes an alias for the
actual parameter there are several potential advantages of this style for larger objects passing
the memory address is more efficient than creating and passing a copy of the objects value passing
by reference also allows a function to intentionally manipulate the callers object if we do not want
to allow a function to mutate its parameter yet we want the efficiency of passing it by reference
a const modifier can be declared with the formal parameter as in
bool isoriginconst point pt 
return ptgetx   0  ptgety   0

with such a signature the point will be passed by reference but the function promises that it will
in no way modify that point a promise that is enforced by the compiler
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 39
8 object models and memory management

page 39

given this discussion of reference variables we revisit our earlier definition of the robust point
class from section 72 notice that our original signature for the distance method on line 19 of
figure 10 appeared as
double distancepoint other const 
the point serving as the parameter is being passed by value causing a local copy to be made
as a value parameter we do not bother to make a const declaration because it does not matter
whether the function body modifies the local value although it does not since a point has several
fields it may be more efficient to pass it by reference in that case we will clearly designate it as
a constant reference with the following revised signature
double distanceconst point other const 
the const for the parameter declaration assures the caller that the the function will not modify its
value while the const declaration that follows the signature designates the method as an accessor
meaning that the point upon which it is invoked is unchanged
we might similarly revise the operator method to receive its parameter as a constant reference
point operatorconst point other const 
return point x  other x y  other y

note that the return type remains declared as a value rather than a reference this is because our
local return value is a transient object that will soon be destroyed it would be unsafe to return a
reference to such an object to the caller so we must send its value
as a final example our original version of the operator method from figure 11 appeared as
ostream operatorostream out point p 
out    pgetx     pgety   
return out


 display using form xy

while we could revise this definition to send the point as a constant reference we wish to draw
attention to the treatment of the ostream as both a parameter and return value notice that the out
parameter is designated as a reference this is because we wish to insert data into the actual stream
indicated by the caller not a copy of the stream in fact streams cannot legally be copied note
as well that this parameter is not designated as a const reference because our insertion of data
impacts the state of that stream
because streams cannot be copied we must return it as a reference using ostream as the
declared return type in our earlier discussion of operator we emphasized that it was not safe to
return its resulting point as a reference the problem there was that the result had been created
in the local scope of the function in the case of operator the stream that we are returning
originated with the caller therefore we may safely return a reference to it knowing that it will
continue to exist after our function completes

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 40
8 object models and memory management

page 40

d  point
0xbffff1234

c
a  point

b  point

x  00
y  00

x  50
y  70

figure 19 variable d is an example of a pointer whose value is the address of instance b

83

pointer variables

c supports a third model for variables known as a pointer this has semantics closest to
pythons model but the syntax is quite different a c pointer variable is declared as follows
point d

 d is a pointer variable

the asterisk in this context declares that d is not a point itself but a variable that can store the
memory address of a point pointers are more general than reference variables in that a pointer is
allowed to point to nothing using the keyword null in c and a pointer can be dynamically
reassigned to the address of another instance a typical assignment statement is as follows
d  b
this leads to a configuration diagrammed in figure 19 we intentionally portray d as a separate
entity because it is itself a variable stored in memory and manipulated whose value just happens to
be a memory address of some other object in order to manipulate the underlying point with this
variable we must explicitly dereference it while the syntax d represents a pointer the syntax d
represents the thing it addresses as a mnemonic consider the original declaration point d which
suggests that d is a point for example we could call the method dgety  which returns
the value 70 in this case the parentheses are necessary due to operator precedence because this
syntax is bulky a more convenient operator  is supported with equivalent syntax dgety 
pointers provide several additional opportunities for a c programmer a pointer can be
sent as parameter to a function as demonstrated in the following revision of isorigin
bool isoriginpoint pt 
return ptgetx   0  ptgety   0

technically what happens is that we declare a new local pointer with the value of that pointer
set to the value of the pointer sent by the caller as a result the function body has indirect access
to the same underlying object that the pointer addresses this provides similar opportunity to
when parameters are passed by value but it allows the additional possibility of the caller sending a
null pointer recall that reference variables must be bound to something the following section
introduces another use of pointers in c that of managing dynamicallyallocated objects

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 41
8 object models and memory management

84

page 41

dynamic memory management

with value variables c handles all issues of memory management when a declaration is made
such as point a the system reserves memory for storing the state of the object furthermore when
that variable declaration goes out of scope for example if a local variable within a function
body the system automatically destroys the object and reclaims the memory for other purposes
generally this automatic memory management eases the burden upon the computer
however there are circumstances when a programmer wants to take a more active role in controlling the underlying memory management for example we might want a function that creates
one or more objects that are to remain in memory beyond the context of the function in c
such a dynamic instantiation is indicated using the keyword new in a context such as new point 
for a default construction or new point57 for a nondefault construction formally the new
operator returns the memory address at which the constructed object is stored to be able to
further interact with the object we must be able to locate it a common approach is to use a
pointer variable to remember the location
point p
p  new point 

 declare pointer variable not yet initialized
 dynamically allocate a new point instance storing its address

with this code fragment two different pieces of memory are being used a certain number of bits
are set aside for managing the pointer variable p while another set of bits are set aside for storing
the state of the underlying point instance the key is that with the dynamic allocation of the
point that instance will remain in memory even when the variable p goes out of scope causing the
reclamation of the variable p but not the object to which it points
management of dynamicallyallocated objects requires more care if a program were to lose
track of the memory location of the object such as by reassigning a pointer variable to a different
location the original object would remain in memory yet be inaccessible4  such a mistake is known
as a memory leak and a program that continues to allocate such objects while never deallocating
them consumes more and more of the computers memory as it runs in c the programmer
has the burden of explicitly destroying a dynamicallyallocated object when it is no longer needed
this is done by using a syntax such as delete p in the above example the expression after the
keyword delete specifies the address of the object to be deleted however delete must only be
used on objects that were dynamicallyallocated if you were to specify the address of a standard
value variable an error occurs when the system subsequently attempts the automatic deallocation

85

treatment of arrays

as a holdover from c arrays are treated rather unusually especially when compared to the more
objectoriented container classes that we will discuss in section 10 in sections  and 42 we had
introduced the basic declaration and use of arrays in c we considered the following example
double measurements300
this declaration causes the system to create an array of 300 double values a particular entry of
that array can be accessed with an expression such as measurements7 in this section we wish to
discuss the treatment of the array as a whole
4

in contrast python detects inaccessible objects and reclaims them as discussed in chapter 1013 of the book
however python must perform additional bookkeeping for all objects to perform that task thus trading efficiency
for convenience

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 42
8 object models and memory management

page 42

the expression measurements without any explicit indexing is a legal syntax in c intuitively that expression relates to the array as a whole but the semantics is not the same as with
a primitive type the expression measurements represents the memory address of the beginning of
the array in fact the formal data type for this expression is a double ie a pointer to a double
the significance of this semantics can be demonstrated with an example assume that our
previous declared measurements has been populated with data we might wish to create a second
array and to copy the original data to the secondary array the following is an errant attempt
double backup300
backup  measurements

 does not actually copy the underlying array

the first line is a legitimate declaration of a second array able to store 300 double values the
problem is that the assignment backup  measurements changes the pointer backup to have a value
equal to the address currently known as measurements in affect we have made the variable backup
an alias for the original array while leaving the newly allocated array inaccessible
there is no direct way to make a copy of an entire array instead we could write our own loop
to initialize the second array with the same values stored in the original
double backup300
for int i0 i  300 i
backupi  measurementsi
the array variable can be used directly as a pointer since measurements is a pointer to
the first array location the expression measurements represents the double stored at that location ie measurements0 c pointers support a notion of arithmetic in that the expression measurements  7 represents the address that is seven entries beyond the start of the array
thus measurements  7 is equivalent in meaning to measurements7
we should also note that c does not make any effort to ensure that our index is legitimate
for example given our earlier declaration use of the expression measurements350 is legal but the
affect is likely disastrous given knowledge of the starting address for the array this expression
refers to the double that is located 350 entries away from the start of the array however since
our array was declared with only 300 entries the memory location that is 350 steps away from the
beginning is not part of the array it could vary well be bits that are being used to represent some
other object in comparing this treatment to that of pythons list we note the tradeoff between
efficiency and convenience if we were to attempt to access measurements350 in python for a list
that did not actually have that many entries an indexerror is thrown python checks the validity
of the index at runtime yet this check requires a few extra steps internally c opts for greater
efficiency by blindly going to the indicated memory location assuming that the programmer has
designated a valid index
the treatment of arrays in c also impacts the way in which we send an array as a parameter
to a function for example we might wish to support a function sum that would support a natural
syntax such as total  summeasurements unfortunately such a calling signature is nontrivial
the challenge relates to the fact that arrays cannot be directly copied en masse when sending
measurements as a parameter what is really being sent is the pointer value yet within the context
of the function we need to know not only where the array begins in memory but also how many
entries there are so a common approach to implementing such a function involves two separate
parameters as demonstrated in the following example

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 43
8 object models and memory management

page 43

double sumdouble data  int n 
double temp  00
for int i0 i  n i
temp  datai
return temp

the first parameter designates that data is in effect an array of doubles although all that is sent is
a pointer to the beginning of the array the second parameter is used to denote the arrays length
the caller must use a syntax such as total  summeasurements 300 when invoking our function
inside the body of the function we index the array using a standard syntax such as datai because
the first parameter is really just a pointer some authors will use the equivalent signature
double sumdouble data int n 
although it is not syntactically clear that data points to an array of doubles rather than a single
double documentation for such a function would designate the proper usage
we also note that either forms of our sum function can be used to compute the sum of a desired
subarray simply by designating the start of the subarray as the first parameter and the length
of the subarray as the second for example the call summeasurements50 10 will compute the
equivalent of pythons summeasurements5060 it involves the subarray starting at the address
of measurements50 containing ten entries fans of pointer arithmetic could make the same call
using the syntax summeasurements  50 10
finally we wish to note that arrays can be dynamicallyallocated rather than relying on automatic memory management this is particular useful when we need to create an array but we do
not know the proper size of the array until runtime in that case we can begin by declaring our
array as a pointer to the base type such as
double measurements
when we wish to dynamically allocate an array of a particular size we can do so using a syntax
measurements  new doublenumentries

 assuming numentires is welldefined

this dynamically allocates an array of double values returning the address of the first entry
as was the case in section 84 a programmer who dynamically allocates an array is ultimately
responsible for releasing the memory when it is no longer needed however to deallocate an array
a programmer must use the delete  operator rather than delete thus if measurements were
dynamically allocated as above it can be destroyed with the command delete  measurements

86

constructors destructors and the assignment operator

constructors in c serve a similar purpose as they do in python they are primarily responsible
for initializing the state of a newly created object for example the simple point class of figure 9
supports a constructor that initializes both data members to the value 00 such a zeroparameter
form is known as a default constructor and is invoked with a user syntax such as
point a

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 44
8 object models and memory management

page 44

the constructor for the more robust point class of figure 10 supports additional calling signatures
for the users convenience it could be invoked for example as
point b57
the point class also supports another constructor form known as a copy constructor even
though we did not provide any explicit code as such this allows a new instance to be initialized
based upon the value of an existing instance for example given our earlier definition of point b
we could instantiate a new point as follows
point cb

 existing point b is the parameter

this creates and initializes a new instance c which is given an initial value patterned upon
instance b but it is important to understand that the new instance is independent in the sense
that it has its own memory and that subsequent changes to one of these points will not affect the
other the first is simply used as a model for the second as the new points x value is set to the
same as the originals x and the new y is initialized to the value of the original y if we were to
describe the behavior of the copy constructor it would be coded as follows
pointconst point other  xother x yother y  

 copy constructor

yet we did not explicitly need such a definition in our point class c provides an implicit
copy constructor for every class that does not explicitly define one by default it performs a
memberbymember copy the primary reason for a default copy constructor is that the system
needs to do its own copying when passing value parameters recall that when a parameter is passed
by value the formal parameter is a local instance that is initialized to match the callers actual
parameter the copy constructor is the mechanism used to create that local instance
however some classes need a more specialized behavior to provide correct copying semantics
in particular there is a potential ambiguity for a class that contains a pointer as a data member
that pointer might be addressing some memory that was allocated specifically for the state of the
given instance or it might be pointing to memory that inherently belongs to some other object
in the former case the correct semantics is to do a deep copy of the object being referenced in the
latter case the correct semantics is likely to replicate the pointer but not to replicate the underlying
object the memberbymember copying mechanism of the default copy constructor in effect is a
shallow copy creating a pointer whose value is the same address as the pointer that is being
copied5  yet c allows the designer of a class to override the semantics of the copy constructor
as a motivating example we develop a simple version of a tallysheet class for integer values
akin to that used in chapter 853 of our book for computing frequency counts we wish to have an
array of counters for the various numbers that are added to the data set yet we do not know how
big of an array to declare until we are told the range of values that may occur for that reason
we must begin by declaring an int data member and then later set that pointer to the address
of a properly allocated array of integers the beginning of our class appears in figure 20 the
pointer tallies is declared at line 6 it is not until the primary constructor is called before we can
compute the required size of the array and then dynamically allocate it line 10 the complication
arises if someone were to make a copy of a tally sheet for example we might imagine a user who
wants to make a copy of a partial tally and then do further simulation on the copy while ensuring
that the original version of the counts remains unchanged
5

we strongly recommend that you revisit chapter 102 of our book for a discussion of these issues in python

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 45
8 object models and memory management

page 45

1 class tallysheet 
2
private
3
int minv
4
int maxv
5
int size
6
int tallies
7
8
public
9
tallysheetint minval int maxval 
10
minvminval maxvmaxval sizemaxvalminval1 talliesnew int size 
11
for int i0 i  size i
12
talliesi  0
13

figure 20 the beginning of a simple tallysheet class
it would be a mistake for us to rely on the systemprovided copy constructor because the tallies
member is a pointer the default copy would result in a new tally sheet with its tallies pointer set to
the same address as the original tallies value in effect the two tallysheet instances would be sharing the same underlying array thereby interfering with an accurate count the proper semantics
for copying a tally sheet is to create a deep copy giving the new instance its own array of counts
albeit initialized based upon the existing counts at that time we provide a specialized version of
the copy constructor by defining an additional constructor that accepts another tallysheet instance
as a parameter for our class we implement the proper copying semantics as follows
14
15
16
17
18

tallysheetconst tallysheet other 
minvother minv maxvother maxv sizeother size talliesnew int size 
for int i0 i  size i
talliesi  other talliesi

the new sheet gets the same minimum maximum and size but rather than aliasing the existing
array we make sure to initialize the tallies pointer to a newly allocated array at line 15 in lines 16
and 17 we use a loop to copy the original array entries into the new array

destructors
just as the constructors of a class are used for initializing the state of a newly created object
there is a method known as a destructor that is invoked each time an object reaches the end of
its lifespan eg a value variable that goes out of scope or a dynamicallyallocated object that is
explicitly deleted as is the case with the copy constructor c will provide an implicit definition
for a destructor if the programmer does not the default behavior invokes the destructor upon
each of the data members
for many classes such as our point class this implicit behavior suffices however ambiguity
exists when pointers are used as data members when an instance is being destroyed should an
object that it references be destroyed as well with the default destructor the memory for the
pointer itself is reclaimed but the object to which it points is not for dynamicallyallocated

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 46
8 object models and memory management

page 46

data such as the tallysheets underlying array we want to deallocate its memory as well we
can override the default behavior by providing an explicit destructor in the class definition by
convention the destructor is a method whose name is the classs name preceded by a  taking
no parameters and providing no return value not even void our tallysheet destructor appears as
19
20
21

tallysheet  
delete  tallies


 deallocate the dynamicallyallocated array

had we not explicitly deleted the dynamicallyallocated array it would remain stranded in memory indefinitely this is in contrast to an array declared as a standard value variable which is
automatically reclaimed upon destruction of an instance

the assignment operator
the assignment operator  is used to assign the lefthand operand the value of the right hand
operator for example with integers variables we write x  y to set the value of variable x equal
to the value of variable y in section 81 we emphasized that for the point class the command
a  b assigns point a the value currently held by b that is a x is assigned the value b x and
a y is assigned the value b y technically the  symbol is an operator and controlled by a
method named operator just as the semantics of  is controlled by operator yet c will
automatically provide a default semantics if we do not implement operator the default is a
memberbymember assignment setting each data member of the lefthand operand to the value
of the respective member of the righthand operand for our point class that is exactly the behavior we want so we did not include an explicit implementation if we had it would appear as follows
point operatorconst point other 
x  other x
y  other y
return this

the assignment of the members x and y is straightforward the noteworthy aspect is the treatment
of the return value at first thought it might seem that an expression a  b is an action but should
not have a resulting value yet it is supposed to have the new value as its result so that assignments
can be chained as a  b  c this treatment is similar to that of the chaining of stream operators
as originally demonstrated in figure 11 on page 33 so we return the point itself as a reference
to avoid unnecessary copying internally we use the keyword this to identify the point instance
being operated upon cs treatment of this is akin to pythons self identifier from a technical
perspective this is a pointer type in c because we want to return the point rather than a
pointer to a point we dereference this in the return statement
while we did not have to explicitly provide the assignment operator for our point class greater
care is necessary for classes such as tallysheet that make use of dynamicallyallocated memory the
tallies pointer on the lefthand side would become an alias for the array on the righthand side and
the original lefthand array would be lost ie a memory leak instead we must ensure that the
instances maintain their own arrays since the existing array for the lefthand instance may not
be the correct size for the renovated state we deallocate the old array and then reallocate a new
array of the correct size then we copy the contents the assignment operator for our tallysheet

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 47
9 generic programming and templates

page 47

class appears as follows
tallysheet operatorconst tallysheet other 
if this  other 
 ignore selfassignments
minv  other minv
maxv  other maxv
size  other size
delete  tallies
 throw away old array
tallies  new int size
 create new array with updated size
for int i0 i  size i
talliesi  other talliesi

return this

the core piece of code is very reminiscent of the commands used in the copy constructor and destructor as we are in essence throwing away our old state and then resetting a new state however
we wish to address one subtlety most of the body is shielded by the condition this  other
when a user invokes an expression such as s  t this is the address of the lefthand operand
while other is a reference to the righthand operand thus other is the memory address of that
instance typically if a user is going to bother to do an assignment the lefthand and righthand
operands will refer to different instances but it is possible for someone to invoke what is known as
a selfassignment such as s  s while it is unlikely that a programmer would author such code
it is legal more commonly a selfassignment may occur when a programmer has two different
references to the same object yet does not realize so in some contexts code written as s  t may
actually involve a single instance
if we recognize that we are being asked to assign an instance its own value we may as well avoid
doing unnecessary work the conditional block serves this purpose notice that the final return
statement must still be executed even for a selfassignment yet our conditional treatment serves
a far more important role than simply for improved efficiency if we did not shield a selfassignment
from this block of code there are disastrous results the problem is that we intentionally deleted the
old array then we create a new array and subsequently try to copy information from other tallies
into tallies while this if fine in the general case if other happens to be the same instance we will
have just thrown away all our data and it is too late to recover it

9

generic programming and templates

the explicit type declarations of c introduces another challenge in comparison to python we
often wish to write pieces of code that are generic in the sense that the same commands can be
applied to a variety of data types for example we might want a function that computes the
minimum of two values or which swaps two values irregardless of the precise data types of those
values we may wish to have a class that manages data in a generic way with flexibility as to the
underling data type
code that is capable of working with a variety of data types is known as polymorphic in
python polymorphism is supported directly through dynamic typing as a programmer can write
functions and classes without explicitly declaring the data types of the parameters c supports
polymorphism using a technique known as templating in this section we discuss the use of
templated functions and templated classes
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 48
9 generic programming and templates

91

page 48

templated functions

in python it is easy to write a generic function that is capable of operating with a variety of data
types as an example we might write a function for computing the minimum of two values as
def mina b
if a  b
return a
else
return b
if we send two integers as parameters this function properly returns the smaller value if we send
two strings as parameters this function returns the one that occurs first alphabetically we do not
need to explicitly declare the data types so long as the  operator is well defined for the given
data the function works at runtime if not a runtime error will occur
with the static typing of c we need additional support for writing such a general function
if we were only interested in such a function for integers we might write
int minconst int a const int b 
if a  b
return a
else
return b

if we were only interested in such a function for strings we might write
string minconst string a const string b 
if a  b
return a
else
return b

but we do not wish to write many different versions of such a function when one suffices the
challenge in c is that we must explicitly declare the type of all parameters and of the return
type support for such generality in c is provided using a mechanism known as a template we
can define a function in a general way by declaring a placeholder for the type name immediately
before the function definition in the case of min the templated function appears as follows
template typename t
t minconst t a const t b 
if a  b
return a
else
return b

the first line designates the identifier t as a hypothetical type name there is not actually a type

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 49
9 generic programming and templates

page 49

with that name and we could have chosen any new identifier as such this serves as what is known
as the template parameter we use it in the signature on the second line to designate the return
value and both parameters as having that same type
when a call such as min5250 is attempted elsewhere in our program the compiler tries to find
a match for the template parameter t that will satisfy the compiletime checking in this particular
example it will recognize that the call matches the function signature when using int in place of
the template parameter t if a call is made with two string instances as parameters the compiler
will resolve the template parameter as type string after matching the template parameters the
compiler then attempts to compile the templated code a compilation error would be reported at
that time for example if min were called on a data type that did not support the  operator used
in the body of our function6 
as a second example we consider the basic task of swapping the values of two variables in
python this can conveniently be done with a simultaneous assignment statement such as ab  ba
in c such a swap of values is typically accomplishes through use of a temporary variable using
an approach like the following
temp  a
a  b
b  temp
however to write such code generically we would need to make a formal declaration for variable
temp and this depends on the data type being used the algorithm library in c provides a
generic implementation of a function with signature swapab that accomplishes this task it can
be implemented as a templated function as follows
template typename t
void swapt a t b 
t tempa
a  b
b  temp

notice that the template parameter is used not only in declaring the parameter types but also
in declaring the local variable temp also note that the parameters are passed by nonconst
references so that assignments within the function body affect the actual parameters of the caller

92

templated classes

in our next example we revise the tallysheet class from section 86 to demonstrate how templating
can be used in a class definition our original python version was designed in a way so that it could
track counts for either integers or onecharacter strings it relied on runtime typechecking so that
when a character is used as a value it is converted to an appropriate integer when computing the
proper array index the c version of tallysheet sketched in the previous section assumed that
the values to be tracked were integers in particular the constructor presumed that minval and
6

as a subtle aside this particular implementation does not properly handle a syntax such as
minhellogoodbye because the literals hello and goodbye are not technically strings they are treated as
character arrays in this particular example with different lengths furthermore the  operator for arrays does not
depend on the content of the arrays but on their memory addresses more care would be required to add support for
such a syntax

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 50
9 generic programming and templates

page 50

maxval were integers as were the data members minv and maxv in this section our goal is to
provide a templated version that can operate on integers or characters
a complete version of the updated class is given in figure 21 we wish to draw attention to a
few aspects of the code we begin by examining the data members declared in lines 47 notice
that minv and maxv are declared using the template parameter type rather than specifically an
int in contrast size is left as an int because the size of the array is an integer even if the user is
tracking characters from a to z similarly we will maintain an array of integer counts even if
those counts represent the number of occurrences of a given character
the standard constructor can be found at lines 1014 notice that the two parameters are typed
as constant references to instances of the template type t in the signature while the rest of this
constructor is identical to the one given earlier in this section there is an important subtlety we
initialize the integer size to be the value maxvalminval1 when the parameters maxval and
minval are integers this is clearly a valid assignment less obviously the assignment is valid even
when maxval and minval are of type char c allows us to subtract one character from another
producing an integer that is the distance between the two characters in the alphabet encoding
the copy constructor destructor and assignment operators lines 1637 are almost verbatim
from the previous section except for the use of the template parameter when designating other
variables of type tallysheett as opposed to the simpler tallysheet we will address this issue
further in section 93 we see the use of the template type t for the parameters of the public
methods increment and getcount as those are values in the users domain as we did in python we
convert such a value to the integer index into the underlying array using a private toindex method
at line 76 that method relies on the use of subtraction for type t similar to our computation of
the size in the constructor
the makelabel method uses a stringstream to convert the index into a string that appropriately
matches the users domain value that technique was introduced in section 66 at line 82 we
use the syntax t to ensure that the label is formatted as the appropriate data type eg int
char because ind is always an int the intermediate expression ind  minv will also be an int
even when minv is a char by surrounding that value with the syntax t it will be correctly
converted to the desired type before being inserted into the stream

93

using templated functions and classes

when calling a templated function the standard calling syntax will often suffice for example
we may use the expression min52 50 with our templated min function and the compiler will
automatically determined that int should be used for the template parameter however the syntax
min1 05 would not be legal the first operand is an int and the second is a double while it is
permissible to send an int to a function that expects a double or to send a double to a function
that expects an int c does not know whether we intended for the template parameter to be int
or double in this case we can make this explicit in the calling syntax as mindouble1 05
similarly in the footnote on page 49 we discussed why a syntax minhellogoodbye was not
supported by our templated function because the literals are not technically strings however we
could legally use the syntax minstringhellogoodbye as the explicit template parameter
make the calling signature clear and string parameters are implicitly created based on the literals
for a templated class such as our tallysheet the declaration of the template parameter is
necessary that is it is illegal to make a declaration
tallysheet frequencyaz

 illegal must specify template parameter

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 51
9 generic programming and templates

page 51

1 template typename t
2 class tallysheet 
3
private
4
t minv
5
t maxv
6
int size
7
int tallies
8
9
public
10
tallysheetconst t minval const t maxval 
11
minvminval maxvmaxval sizemaxvalminval1 talliesnew int size 
12
for int i0 i  size i
13
talliesi  0
14

15
16
tallysheetconst tallysheett other 
17
minvother minv maxvother maxv sizeother size talliesnew int size 
18
for int i0 i  size i
19
talliesi  other talliesi
20

21
22
tallysheet  
23
delete  tallies
24

25
26
tallysheett operatorconst tallysheett other 
27
if this  other 
 ignore selfassignments
28
minv  other minv
29
maxv  other maxv
30
size  other size
31
delete  tallies
 throw away old array
32
tallies  new int size
 create new array with updated size
33
for int i0 i  size i
34
talliesi  other talliesi
35

36
return this
37

38
39
void incrementconst t val 
40
int ind  toindexval
41
if 0  ind  ind  size
42
throw range errorparameter out of range
43
talliesind  1
44

figure 21 templated tallysheet class continued on next page

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 52
9 generic programming and templates

page 52

45
int getcountconst t val const 
46
int ind  toindexval
47
if 0  ind  ind  size
48
throw range errorparameter out of range
49
return talliesind
50

51
52
int gettotalcount  const 
53
int sum  0
54
for int i0 i  size i
55
sum  talliesi
56
return sum
57

58
59
void writetableostream out const 
60
out  value count percent n  n
61
int total  gettotalcount 
62
if total  0
63
total  1
 avoid division by zero
64
65
for int ind0 ind  size ind 
66
string label  makelabelind
67
int count  talliesind
68
float pct  1000  count  total
69
out  setw5  label  setw7  count
70
out  fixed  setw7  setprecision2  pct  endl
71

72

73
74
private
75
int toindexconst t val const 
76
int i  val  minv
77
return i
78

79
80
string makelabelint ind const 
81
stringstream converter
82
converter  tind  minv
83
string output
84
converter  output
85
return output
86

87 
figure 21 continuation templated tallysheet class

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 53
10 c containers and the standard template library

page 53

that is even though the apparent min and max value sent to the constructor are characters the
compiler requires that the template parameter be clearly defined as part of the data type the
correct declaration for such an instance is
tallysheetchar frequencyaz
the official type of our frequency variable is tallysheetchar formally we get a distinct type
definition for each instantiation of the template parameter ie tallysheetchar is distinct from
tallysheetint we see this issue arise in our original code for the class as given in figure 21 for
example the copy constructor definition at line 16 takes a parameter that must be a tallysheett
instance matching the same template parameter as the given instance this makes sense as we
cannot make a tallysheetchar instance as a copy of a tallysheetint instance we see similar
usage in the signature for the assignment operator at line 26 as both the parameter and the return
type are explicitly tallysheett

10

c containers and the standard template library

in python most container types are able to handle heterogeneous data for example it is possible
to have a list composed as 5 alpha a 3 b 5 having three elements the first being an
integer the second a string and the third a dictionary this is possible in python because the list
instance is stored as a sequence of references to objects each reference has equivalent size
in c container types require a static declaration of the element type being stored and thus
they are homogeneous by nature however most container definitions can be applied to a variety
of element types and are implemented using templates for generality templates were discussed
in section 9 the most commonly used data structures have been implemented as part of the
standard template library or stl for short in this section we give a brief introduction to
the main features of that library in section 101 we introduce the vector class as an example
of a typical stl class we give an overview of several other classes in section 102 finally in
section 103 we discuss the concept of an iterator which is used throughout the stl framework

101

the vector class

we begin by examining the vector class which is defined in the vector library a vector is
used to maintain an ordered sequence of values internally the values are stored sequentially in
an array and the class ensures that the underlying array is resized as necessary when elements
are added to the vector a c vector is probably the closest analog to pythons list class but
we more accurately compare it to the more specialized array class in python because a vector is
homogeneous and stored as a collection of values rather than as a collection of references to values
as with pythons list to demonstrate its basic usage we consider the following sample code
vectorstring groceries
groceriespush backbread
groceriespush backmilk
groceriespush backcheese
cout  groceriessize   endl
cout  groceries2  endl
groceries1  juice

a transition guide from python to c

 will be 3
 will be cheese
 replaces milk

michael h goldwasser and david letscher


$$@@$$PAGE: 54
10 c containers and the standard template library

page 54

we start by noting that vector is a templated class in this case we are declaring a vector of
strings by default the newly instantiated vector is empty the push back method is the c
analog of pythons append adding the new value to the end of the sequence the length of the
vector is returned by the size  method as is the case with python elements are zeroindexed and
can be accessed with a syntax such as groceries2 however unlike python c does not check
the validity of an index at runtime it simply trusts the programmer with potential disaster if the
programmer is wrong a safer yet slower way to access an element in c is with the syntax
groceriesat2 this version performs an explicit runtime check of the given index throwing an
out of range exception when warranted there are several other behaviors supported by the vector
class we refer the interested reader to more detailed documentation elsewhere

102

other stl classes

the standard template library contains definitions for many other useful container classes we
focus primarily on those that closely mirror pythons builtin container classes as shown in figure 22 a great advantage of the stl framework is that all of its classes share some common
behaviors and interfaces for example the syntax datasize  is supported uniformly by all of
these data types to report the number of items stored in the container in section 103 we will
discuss how all containers provide a standard syntax for iterating over their elements
the string class is formally part of the stl although it is designed specifically for a sequence
of characters as opposed to a sequence of arbitrary type in contrast to pythons immutable str
class a c string is mutable and supports methods such as append insert and erase that modify
the contents of a string the vector class as introduced in section 101 is an arraybased sequence
of elements with support for arbitrary capacity while the c vector class is quite similar to
the python list class it is important to note that there exists a list class in c supporting an
entirely different concept the c list class represents an ordered sequence of elements but one
that is stored internally as what is known as a linked list rather than the arraybased vector
both python and c support a set class but they use different underlying data structures
and provide different guarantees in terms of ordering and efficiency pythons sets are implemented
using an approach known as hashing described in chapter 1332 of our book this approach
provides constanttime operations in general but the elements of the set are not wellordered in
contrast the c set class represents an ordered set implemented using a balanced binary search
tree similar to that described in chapter 134 of our book for this reason the elementtype for a
set must define a total ordering by default based on an implementation of operator
we relied on the set class in an earlier piece of code in this document namely when implementing
the deluxetv class in figure 12 on page 34 at line 3 of that code we declare instance variable
favorites having templated type setint we add an element to the set at line 11 using the insert
c type

description

python analog

string

character sequence

str

vector

arraybased expandable sequence homogeneous

list or array

list

linked sequence homogeneous

set

ordered set of unique elements homogeneous

set

map

associative mapping homogeneous

dict

figure 22 commonly used classes from cs standard template library stl

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 55
10 c containers and the standard template library

page 55

method and we remove an element at line 13 using the erase method we will discuss the rest of
that example after introducing the concept of iterators in section 103
finally the c map class is the analog to the python dict class rather than storing a
set of elements it manages a collection of keyvalue pairs as such it requires two template
parameters the first specifying the keytype and the second the associated valuetype as an
example we could have implemented the tallysheet to keep track of frequencies by maintaining
a map from some key type to an integer frequency for example if counting characters we may
declare mapchar int tallies as is the case with sets c uses balanced binary trees to
implement maps and the key type must define a total ordering typically with operator

103

iterators

because a string or vector instance is stored in an underlying array integer indices can be used to
efficiently describe the position of an element to be accessed for most other stl container types
integer indices are not supported this is typically because a container is not inherently ordered or
because the underlying storage mechanism is not consistent with such a convention for example a
list instance implemented as a linked list or a set instance implemented as a balanced search tree
for this reason all stl containers including strings and vectors provide support for describing
a position of an element using an instance of an iterator class iterator instances cannot be
directly created by a user rather they are initially returned by some method of the class these
iterators are then used to identify a particular element or location within a container in the context
of parameters and return values conceptually they are similar in purpose to a pointer but they
are not necessarily a direct representation of a memory address to explore the syntactic use of
iterators we revisit a code fragment from our deluxetv class definition in figure 12
17
18
19
20

setintiterator result  favoritesupper bound channel
if result  favoritesend 
result  favoritesbegin 
 wrap around to smallest channel
setchannelresult
the result variable is defined to have type setintiterator formally this is an instance of an
iterator class that is nested within the scope of the setint class this is different from other
iterator classes such as setstringiterator or vectorintiterator
the value of result is initialized to the result of the call to upper bound a method specific to the
set class before explaining the semantics of upper bound we describe a related method named find
supported by sets a call such as favoritesfindvalue checks to see if the given value is contained in
the set akin to the contains method in python if found an iterator representing that elements
position in the set is returned if not the sentinel end  is returned by convention to designate
the lack of such an element in contrast the upper bound method is one that relies on the fact
that cs sets are ordered the formal semantics of a call to upper boundvalue is to locate the
smallest value in the set if any that is strictly greater than the parameter so in the context of
deluxetv we are looking for the next favorite that is found when moving upward from the current
channel setting if there is no element of the set with a value greater than channel the end sentinel
is returned just as is done with find we detect that case at line 18 for the television model our
goal was to then wrap around to the smallest of all favorite channels we accomplish this goal at
line 19 by calling another method named begin in some sense this is the opposite of end except
that the result of begin is an iterator to the first actual position in the set rather than a sentinel
in the case of sets the ordering begins with the least element

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 56
11 error checking and exceptions

page 56

the final lesson portrayed by the above code involves the use of syntax result at line 20 in
context the call to setchannel is used to implement the change of channels and the parameter to
that call must be the desired channel value just as there is a distinction between a pointer and
the value to which it points we must make a distinction between an iterator and the underlying
element to which it refers in this context result is the iterator while result is the corresponding
int value from the set namely the favorite channel number
iterators can also be used to iterate through all elements of an stl container hence the term
iterator as an example here is code that prints out all favorite channels for our deluxetv using
the  operator to advance from one position to the next
for setintiterator walk favoritesbegin  walk  favoritesend  walk
cout  walk  endl
note the significance between the asymmetric convention of begin and end so long as the iterator
is not equal to the end sentinel it represents the position of an actual element that can be printed
when walk becomes equivalent to the end the loop terminates note that for an empty set the
result of begin  is precisely that of end  and so there are zero iterations of the loop this
form of loop is supported by all stl containers we note the correspondence between going from
begin up to but not including end just as python handles ranges startstop iterators for many
containers also support backwards iteration with the  operator indexed classes such as vector
and string support randomaccess iterators that allow arbitrary step sizes using arithmetic such
as begin 5 or end 3
finally we note that an assignment such as walk  val can be used to modify an element of a
container inplace however if a container is designated as readonly with const modification of
elements is not allowed for this circumstance all stl containers support a second class named
const iterator that is similar to iterator but without the ability to modify the contents of the
underlying container note well that a const iterator is not the same as a const iterator as the
former can be incremented and decremented but without modifying the underlying container while
the latter can modify the underlying container but cannot be incremented or decremented

11
111

error checking and exceptions
overview

as is the case with python c provides support for throwing and catching exceptions as a way
to handle exceptional cases that arise at runtime c defines an exception type that is the base
class for a hierarchy of standard exception types defined in the stdexcept library for example
there is an out of range exception in c that is similar in purpose to pythons indexerror and a
domain error in c that is similar to pythons valueerror programmers are also free to define
their own subclasses derived from exception in sections 112 and 113 we will give a brief overview
of the syntax for throwing and catching exceptions in c however exceptions are not the
only way that c manages errors in section 114 we will discuss several other approaches for
errorhandling

112

throwing an exception

one of the examples we used in python was that of a sqrt function that throws an exception when
the argument is a negative number the implementation for such a function might begin as follows

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 57
11 error checking and exceptions

page 57

def sqrtnumber
if number  0
raise valueerrornumber is negative
python uses the keyword raise to throw an exception with the remaining argument being an
instance of the exception class to be thrown in this example valueerrornumber is negative
denotes the construction of a new instance of type valueerror with the constructor for that class
accepting an error message as a string parameter the syntax in c is quite similar except that
we use the keyword throw rather than pythons raise the same code fragment would appear as
follows in c
double sqrtdouble number 
if number  0
throw domain errornumber is negative

113

catching an exception

exceptions can be caught and handled in both python and c using a try construct in python
we saw that the corresponding handlers were labeled with the keyword except in c the corresponding handlers are labeled with the keyword catch as with python there can be any number
of catch clauses as part of a try construct each looking for one particular type of error and there
can be a final clause that catches anything else that was not yet caught a generic example of the
c syntax is as follows
try 
 any sequence of commands possibly nested
 catch domain error e 
 what should be done in case of this error
 catch out of range e 
 what should be done in case of this error
 catch exception e 
 catch other types of errors derived from exception class
 catch  
 catch any other objects that are thrown

if an exception is encountered it will be handled by the first clause with a matching type declaration
the final clause with parameter  will match any object if there were not such a final clause
and an exception occurs that does not match any of the existing clauses that exception would
be propagated to any outer nested scope where it might be caught or if uncaught will cause the
program to terminate note that for all but the final case the exception handler clause has access
to the declared variable e with local scope that is a reference to the exception instance that has
been caught additional information about that exception can be determined for example with
the call ewhat  which returns the string message used when the exception was instantiated

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 58
11 error checking and exceptions

114

page 58

other approaches to errorhandling

despite having support for formally throwing and catching exceptions this is not the only mechanism used by c for managing exceptional cases in fact due to legacy code other techniques
are far more commonly seen in the standard packages
as an example consider what happens when you attempt to divide an integer by zero in
python this causes a formal zerodivisionerror to be raised and a programmer could write code to
catch such an error in c the behavior of such a division by zero is inherited from treatment in
c and so it causes a runtime error but not formally by means of a throw statement as a result
it cannot in general be caught within a try construct a programmer who is concerned about the
validity of a division must check the denominator before performing the operation to avoid any
such error
another legacy behavior from c is the treatment of array indexing in section 85 we discuss
how c computes the address of an array entry by using the index to compute a relative offset
from the beginning of the array we also noted that c does not explicitly check whether an
index is within range for a declared array and so access to an expression like measurementsk
for a k that is too larger or is negative will likely have dire but unpredictable consequences in
python indices are always validated at runtime a c programmer could also do such checks
to ensure that an index always lies in the appropriate range however performing such a check at
runtime is a burden on the system if a programmer is confident in the logical design of a program
there is no need to explicitly perform such checks but logical errors involving invalid indices are
difficult to detect and diagnose since both strings and vectors in c are implemented using
cstyle arrays internally the same issues arise as to how to handle errorchecking of indices the
designers of those classes struck a compromise in section 101 we differentiated between the two
syntaxes measurementsk and measurementsatk that are supported by strings and vectors the
first is the more efficient version that does not explicitly errorcheck the index value but which has
indeterminate behavior when errant in contrast the at method performs a runtime check of the
given index formally throwing a out of range exception when errant
yet another mechanism for detecting errors is used by c for most io tasks such as
reading formatted data or working with files as a basic example we revisit the goal of reading a number from 1 to 10 from a user in python this is accomplished with the command
number  intraw inputenter a number from 1 to 10  noting that the call to raw input
might throw exceptions if there were failures to read data from the user and that the call to the
int constructor will fail if the string returned by raw input is not a legitimate representation of
an integral value in python more robust code is based on catching the various exceptions that
occur with appropriate remedy our more robust c version of that task was given in figure 8
on page 27 by default c uses a mechanism based on what are known as error flags a command such as cin  number does not formally throw any exceptions instead if various problems
arise they are tracked through extra fields associated with the stream instance we can check for
error cases after the command by polling those various flags using calls such as cinfail  cineof 
cinbad  each of which denotes one of a certain set of possible errors that have occurred once
an error flag has been set it is up to the program to find remedy and to explicitly unset that
flag if the stream is going to continue to be used please review the prose on page 27 for further
explanation of that example
error flags are similarly used in c when working with file streams as a tangible example
figure 86 on page 283 of our book gives a python function for opening an existing file based on a
filename given by the user with appropriate errorchecking to ensure success in translating that
example to c we cannot return a local variable for the resulting file stream as file streams
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 59
12 managing large projects

page 59

void openfilereadrobustifstream source 
sourceclose 
 disregard any previous usage of the stream
while sourceis open  
string filename
cout  what is the filename 
getlinecin filename
sourceopenfilenamec str 
if sourceis open 
cout  sorry unable to open file   filename  endl


figure 23 a c function for robustly opening a file with readaccess
cannot be passed by value so we use a signature in which the caller passes an uninitialized file
stream as a parameter and the functions responsibility is to open the underlying file our c
variant is given in figure 23 notice that we rely on polling the result of is open  this method is
supported by the file stream classes in addition to the other accessors such as eof and bad inherited
from the more general stream classes

12

managing large projects

thus far we have assumed that source code for a project is contained in a single file for mediumand largescale software projects it is more common to have source code divided among many
different files there are several advantages to such a design a multifile structure can support a
more natural decomposition for complex project while also allowing a team of developers to edit
different files concurrently furthermore having components of a program in different files provides
a better structure for version control and reuse of source code across projects
as a simple demonstration of a more typical c structure we revisit our first example from
figure 1 on page 7 in which we define a gcd function as well as a main function for testing it
a multifile version of that project might appear as in figure 24 in our new design we have
intentionally separated the implementation of the gcd function from the piece of code in this case
the main function that relies upon the gcd function to coordinate the interactions between those
two we created the file gcdh which is known as a header file note that we were not required to
name the file gcdh but this choice is reasonably conventional the purpose of that file is not to
implement the gcd function but to provide a formal definition of its interface this is accomplished
at line 3 of that file which gives the full signature of the function but without a subsequent function
body we will discuss the purpose of the other lines in gcdh later
with the information encapsulated in the header file we are able to independently define the two
other components of our software we use the include gcdh directive from within the other
files to load this definition this is the same directive we have already seen for loading definitions
from standard libraries such as with iostream at line 2 of gcdtestcpp the distinction between
the quotation marks around gcdh versus the angle brackets around iostream is because we
presume that the gcdh file is stored in the same directory as the file gcdtestcpp whereas the
iostream library definitions are installed elsewhere on the system in a path known to the compiler
with gcdh included from within gcdtestcpp the compiler is able to verify the proper usage

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 60
12 managing large projects

page 60

gcdh
1
2
3
4

ifndef gcd h
define gcd h
int gcdint u int v  forward declaration
endif

gcdcpp
1 include gcdh
2
3 int gcdint u int v 
4
 we will use euclids algorithm
5
for computing the gcd 
6
int r
7
while v  0 
8
r  u  v  compute remainder
9
u  v
10
v  r
11

12
return u
13 

gcdtestcpp
1
2
3
4
5
6
7
8
9
10
11
12
13

include gcdh
include iostream
using namespace std
int main  
int a b
cout  first value 
cin  a
cout  second value 
cin  b
cout  gcd   gcdab  endl
return 0


figure 24 gcd project with source code consisting of three files
of the call to the gcd function at line 11 note well that it does not matter in that context how the
gcd function is implemented only that the type of parameters and return value are known
the purpose of the gcdcpp file is to implement the gcd function we include the header file
at line 1 to ensure consistency of the signature although this is not technically required

121

compilation and linking

in the original version of our project with all code within a singlefile named gcdcpp we compiled
the program into an executable named gcd with the following command
g  o gcd gcd  cpp
with our new design the appropriate compiler command for building an executable named gcd is
the following
g  o gcd gcd  cpp gcdtest  cpp
notice that we provide both files gcdcpp and gcdtestcpp as inputs to the compiler this
is because each of them includes part of our implementation in contrast we do not explicitly
indicate the header file gcdh the definitions from within that file are already explicitly included
by the include directive when compiling the other files
to build the executable both parts of the source code must be individually compiled and then
those parts are combined to create the final executable formally these are separate stages of
the compilation process since the implementation of the function in gcdcpp does not overtly
depend upon the code that calls the function the compiler can analyze it independently checking
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 61
12 managing large projects

page 61

for validity and converting the highlevel commands into appropriate machine code similarly the
commands of the main function in gcdtestcpp can be independently compiled into machine code
without regard to the details of the gcd function body
the final stage of the compilation process is known as linking once the individual pieces have
been converted to machine code the system must assemble them into a single coherent executable
that can be executed on the system the primary goal of the linking stage is to ensure that all
necessary functions have been defined in precisely one of the components that is if we tried to
compile the file gcdtestcpp without gcdcpp the linker would report an error that it cannot
find the implementation of the function gcd that is being called from within main in contrast if
we were to attempt to compile gcdcpp without gcdtestcpp the linker would complain that it
cannot find a main function a requirement for any executable
the given g command from above performs both the compilation and linking phases by
default that said it is possible to request that a component be compiled but to defer the linkage
for example to compile the gcd function but not yet link it to any executable we could execute
the command
g  c gcd  cpp
the c flag in the command is what designated our desire to perform compilation only the result
of a successful compilation in this case is a new binary file named gcdo that is known as object
code one advantage of having this object code stored in a file is that it allows us greater reuse
without additional compilation for example if we wanted to use our gcd function in several
projects each of those could make use of our precompiled object code rather than recompiling
from the original source code in our example if we presume that we have preliminary created
both gcdo and gcdtesto as object code we can invoke the final linking to produce an executable
with the command
g  o gcd gcd  o gcdtest  o
for largescale problems there is another great advantage of separating out the compilation
of object code from that of the linking phase if you envision a project that might be composed
of hundreds if not thousands of files the full compilation process is a timely one during the
development cycle it is common to have compiled the program to make changes to one or more
of the source code files and then to recompile the entire project however with good modular
design a change to one piece of source code should not effect most of the other components in
this case we will need to regenerate the object code for the modified source code and perhaps a
few other dependent pieces but the majority of the components will not need to be rebuilt from
scratch instead those few components can be recompiled into object code and then all of the
object code can be relinked to form a new executable although the linking phase requires some
work it is not nearly as timeconsuming as the original compilation
finally we note that for larger problems there are other tools to assist developers in managing
their projects for example many integrated development environments ides will keep track of
which pieces of source code have been modified and which need to be recompiled when building a
new executable one of the classic tools for developers in managing the rebuilding of a project is a
program known as make this program relies upon a configuration file for the project conventionally
named makefile the makefile designates what components comprise the project and upon which
pieces of source code each component depends the make command causes a rebuild of the entire
project but relying on the filesystem timestamps to determine which pieces of source code have
been edited since the previous build

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 62
12 managing large projects

122

page 62

avoiding multiple definitions

header files are typically used to provide formal declarations of functions or classes it seems
pretty clear that you would not want to include two conflicting definitions for something as it
happens it is also illegal to repeat the same definition for something more than once while this
might seems easy to avoid there are several pitfalls when including header files throughout a larger
project for example assume we have an application that will rely on our gcd function as well as
a fraction class source code for that project might naturally start with the following declarations
include gcdh
include fractionh
the problem is that the definition of the fraction class might also depend upon use of the
gcd function for reducing fractions to lowest terms so it is possible that there might be an
include gcdh within the fraction header file if this were the case then the contents of gcdh
are inherently being included twice in the above code
to properly avoid errant repetitions of definitions from a header file those files take advantage of
other preprocessor directives as shown in our gcdh file from figure 24 these directives beginning
with  are not formally c syntax rather a separate set of commands that are understood by
the compiler as with include our gcdh file begins with the ifndef gcd h directive on line 1
paired with the endif directive on line 4 the ifndef syntax is short for if not defined it looks
for whether the term gcd h has been previously defined only using the body of that conditional
when it has not been defined in this context the first time we included the contents of gcdh no
such symbol gcd h has been defined and so we will include the body of that conditional lines 2
and 3 the purpose of the define gcd h directive on line 2 is to introduce the symbol gcd h
to the compiler so that the ifndef directive at line 1 will fail for any subsequent inclusions of
gcdh we will use a similar guard mechanism for all header files in a larger project choosing a
distinct symbol for each eg gcd h
line 3 of the file gcdh is a forward declaration of the gcd function this defines the signature
of the function yet we do not explicitly include the body of the function in that file the forward
declaration has the relevant information for doing compiletime checking for example when making
the call to gcd from within gcdtestcpp so the function body is not needed more importantly it is
important that we do not place the body of the gcd function inside the header file otherwise there
would be a problem if two or more cpp files include such a header each cpp file is independently
compiled into object code and so the ifndef guard would allow the definition to be read once for
each cpp file having the forward declaration in each is permissible but if the function body were
included the compiled version of that body would be embedded within the object code associated
with each cpp file this in turn would cause a linkingerror when the object codes were combined
as there would be duplicate definitions for the function to contend with in our actual project it
is only the compiled version of gcdcpp that has the implementation of the gcd function so there
is no ambiguity when compiling and linking

123

namespaces

another concern with larger projects is that several components may wish to use the same identifier
for a feature such as a variable function or class if all components were authored by the same
team perhaps such naming conflicts could be avoided however often we need to rely upon software
packages written by others that cannot be modified for example a civil engineering application
might need to include an architecture package that defines a window class ie a plane of glass and
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 63
12 managing large projects

page 63

a graphical user interface package that defines its own window class ie a rectangle on a computer
screen including such conflicting definitions for the identifier window would be illegal
python tackles the issue of namingconflicts by supporting two forms for import a command
such as import architecture introduces the name architecture into the default namespace as an identifier for the imported module then a qualified name architecturewindow can be used to describe
the window class from that module in contrast a syntax such as from architecture import window
introduces the name window directly into the default namespace however this form would be conflicting with another command from gui import window in c name conflicts can be mitigated
by organizing related definitions into a separate namespace using a syntax such as the following
namespace architecture 
class window 


class building 



after this definition the window class can be identified with a qualified name architecturewindow
this style would allow another part of a program to include the architecture code and to include
the gui code while being able to differentiate unambiguously between architecturewindow and
guiwindow at the same time it is possible for a programmer to introduce definitions from such a
namespace into the default namespace for example following the above definition a subsequent
command using architecturewindow would introduce the architecturewindow definition into the
default namespace with the unqualified name window akin to from architecture import window in
python all definitions from a namespace can be added to the default namespace for example
using the command using namespace architecture akin to from architecture import  in python
we have already seen such a use of namespaces in our c code by default most standard
libraries in c introduce their definitions into a special namespace identified as std rather than
directly in the default namespace for example the iostream library defines the streams cin and
cout into the std namespace since the fullyqualified names stdcin and stdcout require extra
typing programmers often bring everything from the standard namespace into the default with the
command using namespace std such as at line 3 of our gcdtestcpp program in figure 24

124

managing class definitions

in section 122 we emphasized that header files should provide function definitions but not implementations for those functions the rule is somewhat different in regard to member functions of
a class definition the implementation for those functions can either be given directly within the
context of the class definition or externally as a demonstration we revisit the robust definition
of the point class as originally shown in figures 10 and 11 in section 72 our revised version has
been divided into two files pointh and pointcpp as shown in figures 25 and 26 respectively
the header file defines the point class specifying the data members and the signatures of the
member functions notice that for some simple functions such as getx and setx we have embedded
the function bodies directly within the header file formally those are processed by the compiler so
that they become inlined code at runtime rather than a formal function call in most other cases
we defer the implementation of the function to the pointcpp file note well that we chose note to

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 64
12 managing large projects

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27

ifndef point h
define point h
include iostream

page 64

 need ostream definition for operator signature

class point 
private
double x
double y
public
pointdouble initialx00 double initialy00
double getx  const  return x 
void setxdouble val  x  val 
double gety  const  return y 
void setydouble val  y  val 
void scaledouble factor
double distancepoint other const
void normalize 
point operatorpoint other const
point operatordouble factor const
double operatorpoint other const
  end of point class






inlined
inlined
inlined
inlined

function
function
function
function

body
body
body
body

 freestanding operator definitions outside the formal point class definition
point operatordouble factor point p
stdostream operatorstdostream out point p
endif
figure 25 pointh header file for our point class
state using namespace std from within the header file to avoid polluting the default namespace
for others including this file as a result we explicitly designated the type stdostream at line 26
looking at figure 26 we see the remaining implementations of the functions from the point
class since this file is not directly being included by others we promote the std namespace to
the default at line 4 for our convenience we wish to draw attention to the form of the signatures
in this file for example that of pointscale at line 8 because this code is not formally included
within the scope of the original point class definition we cannot simply write the signature as
void scaledouble factor
that would appear to be the signature of a standalone function named scale rather than the
member function of the point class with that name to properly declare that we are implementing
the member function we must use the qualified function name pointscale to reestablish the proper
scope having done so the body itself is interpreted with the proper context therefore we are
able to access data members such as x and y as done on lines 9 and 10 notice that at line 20
within the body of the normalize function we are able to call the distance method within need to
qualify it as pointdistance because the proper scope has already been established for the body
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 65
12 managing large projects

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46

include pointh
include iostream
include cmath
using namespace std

page 65

 for use of ostream
 for sqrt definition
 allows us to avoid qualified stdostream syntax

pointpointdouble initialx double initialy  xinitialx yinitialy  
void pointscaledouble factor 
x  factor
y  factor

double pointdistancepoint other const 
double dx  x  other x
double dy  y  other y
return sqrtdx  dx  dy  dy
 sqrt imported from cmath library

void pointnormalize  
double mag  distance point  
if mag  0
scale1mag


 measure distance to the origin

point pointoperatorpoint other const 
return point x  other x y  other y

point pointoperatordouble factor const 
return point x  factor y  factor

double pointoperatorpoint other const 
return x  other x  y  other y

 freestanding operator definitions outside the formal point class scope
point operatordouble factor point p 
return p  factor


 invoke existing form with point as left operand

ostream operatorostream out point p 
out    pgetx     pgety   
return out


 display using form xy

figure 26 pointcpp source code for our point class
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 66
12 managing large projects

page 66

as a final comment we draw attention to our treatment of the two standalone functions
namely operator and operator that provide support for operator usage when the point is
a righthand operand in our original treatment of the point class we explained the need for
having those definitions outside the formal class they remain as such in our new design with
forward declarations given at lines 25 and 26 of pointh and implementations given at lines 39
46 of pointcpp because these are not formal member functions note that we do not designate
point scope in their signatures for example line 43 of pointcpp names the function operator
rather than pointoperator in similar spirit line 39 defines operator not to be confused from
the forms of pointoperator that are given at lines 29 and 33

125

managing templated classes

the conventions are different for templated classes in a multifile project the main issue is that
templated code is not precompiled into independent objectcode because the underlying machine
code depends intricately on the actual data type supplied as the template parameter therefore
templated code is compiled as needed when instantiated from other contexts as a result we use
a slightly different convention for embedding the source code within separate files
there remains a choice of whether to embed implementations for member functions withing
the formal class definition or externally however even when external to the class definition
the implementations must formally be included directly or indirectly as part of the header file
rather than as a separately compiled cpp file still to ease in the separation of the interface and
implementation it is a common convention to have a separate h file in the style of the standard
class and the bodies in another file using a special suffix such as tcc that is to differentiate it
from a standard cpp file the tcc file is explicitly included from within the header file
as a concrete example we refer to appendix a1 of this document where we give a complete
implementation of our tally sheet project in particular we give code for tallysheeth in figure 28 we draw particular attention to line 80 of that source code which reads
include tallysheettcc
this causes all the definitions from the second file to be explicitly included from within the header
and thereby indirectly included by any other file that includes the header
finally we look at the style for implementing member functions within the tallysheettcc
file as shown in figure 29 in the appendix as was the case with our point class it is important
to reestablish the proper scope when declaring the function signature because we are defining
functions of a templated class we must use the formal template syntax for each individual function
as shown in the following excerpt
85 template typename t
86 string tallysheett makelabelint ind const 
87
stringstream converter
88
converter  tind  minv
89
string output
90
converter  output
91
return output
92 

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 67
12 managing large projects

126

page 67

unit testing

in python we demonstrated how unit tests could be embedded in the same file as a module using
the construct
name

if

 __main__

that convenient style allows for test code to be run conditionally when the interpreter is executed
directly on that file but ignored when the module is imported from some other file
unfortunately there is no standard way to embed unit testing within the same source code
files as the code that is to be tested the issue is that any executable must begin with a call
to a main routine but when multiple files are compiled and linked there must be precisely one
main routine defined this was precisely the problem we pointed out with our original singlefile
implementation of the gcd program from figure 1 on page 7 because the main routine is defined
in that file it becomes impossible for any other applications with their own main routine to be
combined with this definition of the gcd function that is why the revised version introduced at
the beginning of this section relies on having a separate gcdtestcpp file for testing the unit test
can be compiled by combining both gcdcpp and gcdtestcpp when compiling however we could
build other executables that rely on gcd by linking some source code with gcdcpp but without
gcdtestcpp

127

documentation

python also provided a builtin mechanism for embedding documentation strings directly within
the source code files with standard tools for generating documentation based upon those strings
although comments can be embedded within c source code there is no support for generating
documentation from those comments in the standard c distribution that said there is a
widelyused thirdparty tool known as doxygen see wwwdoxygenorg that can be used to embed
actionable documentation within source code
doxygen supports several choices of conventions one such style relies on comments between
delimiters  and  note that the starting delimiter  begins with  and therefore it is
recognized by the c compiler as a standard comment but the additional asterisk causes
doxygen to treat this as formal documentation we demonstrate this style of comments throughout
the source code given in the appendix to this document as an example figure 35 of appendix a2
shows a documented version of a pattern class for the game mastermind the compareto function
of that class is documented as follows
46
47
48
49
50
51
52




brief compare the current pattern to another and calculate the score





param otherpattern the pattern to be compared to the current one
return a score instance representing the result


score comparetoconst pattern otherpattern const


within the comment we use reserved control sequences such as brief param and return to tag
key pieces of information when compiled with doxygen the documentation for the function might
be rendered as in figure 27

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 68
a full source code

page 68

figure 27 sample documentation produced by doxygen

a

full source code

as a conclusion we offer complete source code that mirrors several projects that were implemented
in python within our book

a1

tally sheet and frequency counting

this section contains complete c code for a project that closely mirrors the python project
originally presented in chapter 853 of our book for computing frequency counts the tallysheet
class we use here is similar to the templated one from section 92 however this time we break it into
separate tallysheeth and tallysheetcpp files shown in figures 28 and 29 respectively including full documentation we also include a c version of the fileutilities component given in our
python version this consists of files fileutilitiesh and fileutilitiescpp figures 30 and 31
respectively finally we give two sample applications using these tools specifically figure 32 displays the contents of file countletterscpp the main driver for computing letter frequencies and
figure 33 contains countscorescpp the corresponding driver for counting integer scores

a2

mastermind

as our final project we implement a textbased version of the mastermind game based closely
upon the design of our python version from chapter 7 of our book this project consists of the
following components
 a score class as defined in scoreh of figure 34 there is no scorecpp because we inline
all of the function bodies for this simple class
 a pattern class as defined in patternh of figure 35 and patterncpp of figure 36
 a textinput class as defined in textinputh of figure 37 and textinputcpp of figure 38
 a textoutput class as defined in textoutputh of figure 39 and textoutputcpp of figure 40
 a mastermind class as defined in mastermindh of figure 41 and mastermindcpp of figure 42
 the main driver for our textbased game implemented in mastermind maincpp of figure 43

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 69
a full source code

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41

page 69

ifndef tallysheet h
define tallysheet h
include iostream



brief manage tallies for a collection of values





values can either be from a consecutive range of integers or a
consecutive sequence of characters from the alphabet


template typename t
class tallysheet 
private
t minv
t maxv
int size
int tallies

public

 brief create an initially empty tally sheet




param minval the minimum acceptable value for later insertion
param maxval the minimum acceptable value for later insertion


tallysheetconst t minval const t maxval




brief make a copy of the given instance


tallysheetconst tallysheett other




brief assign one instance the state of another


tallysheett operatorconst tallysheett other




brief destruct the current instance


tallysheet 

figure 28 contents of tallysheeth file continued on next page

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 70
a full source code

42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81

page 70


brief increment the tally for the respective value

void incrementconst t val




brief return the total number of current tallies for the given value

int getcountconst t val const






brief return the total number of current tallies


int gettotalcount  const




brief write a comprehensive table of results




report each value the count for that value and the percentage usage



param out an open output stream

void writetablestdostream out const



private

 brief convert from a native value to a legitimate index


return the resulting index such that minv is mapped to 0

int toindexconst t val const




brief convert index to a string in native range

stdstring makelabelint ind const




include tallysheettcc
endif
figure 28 continuation contents of tallysheeth file

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 71
a full source code

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46

page 71

include iostream
include stdexcept
include iomanip
include sstream
using namespace std
template typename t
tallysheetttallysheetconst t minval const t maxval 
minvminval maxvmaxval sizemaxvalminval1 talliesnew int size 
for int i0 i  size i
talliesi  0

template typename t
tallysheetttallysheetconst tallysheett other 
minvother minv maxvother maxv sizeother size talliesnew int size 
for int i0 i  size i
talliesi  other talliesi

template typename t
tallysheetttallysheet  
delete  tallies

template typename t
tallysheett tallysheettoperatorconst tallysheett other 
if this  other 
 ignore selfassignments
minv  other minv
maxv  other maxv
size  other size
delete  tallies
 throw away old array
tallies  new int size
 create new array
for int i0 i  size i
talliesi  other talliesi

return this

template typename t
void tallysheettincrementconst t val 
int ind  toindexval
if 0  ind  ind  size
throw range errorparameter out of range
talliesind  1

figure 29 contents of tallysheettcc file continued on next page
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 72
a full source code

47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92

page 72

template typename t
int tallysheettgetcountconst t val const 
int ind  toindexval
if 0  ind  ind  size
throw range errorparameter out of range
return talliesind

template typename t
int tallysheettgettotalcount  const 
int sum  0
for int i0 i  size i
sum  talliesi
return sum

template typename t
void tallysheettwritetableostream out const 
out  value count percent n  n
int total  gettotalcount 
if total  0
total  1
 avoid division by zero
for int ind0 ind  size ind 
string label  makelabelind
int count  talliesind
float pct  1000  count  total
out  setw5  label  setw7  count
out  fixed  setw7  setprecision2  pct  endl


template typename t
int tallysheett toindexconst t val const 
int i  val  minv
return i

template typename t
string tallysheett makelabelint ind const 
stringstream converter
converter  tind  minv
string output
converter  output
return output

figure 29 continuation contents of tallysheettcc file
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 73
a full source code

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22

page 73

ifndef file utilities h
define file utilities h
include string
include fstream



brief repeatedly prompt user for filename until successfully opening with read access



param fin input file stream to be opened

void openfilereadrobuststdifstream fin







brief repeatedly prompt user for filename until successfully opening with write access







param fout output file stream to be opened
param defaultname a suggested filename this will be offered
within the prompt and used when the return key is pressed without
specifying another name


void openfilewriterobuststdofstream fout const stdstring defaultname
endif


figure 30 fileutilitiesh header file

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

include fileutilitiesh
include fstream
include iostream
using namespace std
void openfilereadrobustifstream source 
sourceclose 
 disregard any previous usage of the stream
while sourceis open  
string filename
cout  what is the filename 
getlinecin filename
sourceopenfilenamec str 
if sourceis open 
cout  sorry unable to open file   filename  endl


figure 31 fileutilitiescpp implementation continued on next page

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 74
a full source code

page 74

17 void openfilewriterobustofstream fout const string defaultname 
18
cout  within openfilewriterobust  endl
19
foutclose 
20
while foutis open  
21
string filename
22
cout  what should the output be named   defaultname   
23
getlinecin filename
24
if filenamesize   0
25
filename  defaultname
26
foutopenfilenamec str 
27
if foutis open 
28
cout  sorry unable to write to file   filename  endl
29

30 
figure 31 continuation fileutilitiescpp implementation
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27

include fileutilitiesh
include tallysheeth
include cctype
include iostream
include fstream
using namespace std

 provides isalpha and toupper

int main  
ifstream source
ofstream tallyfile
tallysheetchar sheeta z
cout  this program counts the frequency of letters  endl
cout  only alphabetic characters are considered  endl  endl
openfilereadrobustsource
while sourceeof  
char character
source  character
if isalphacharacter
sheetincrementtouppercharacter

sourceclose 
openfilewriterobusttallyfile frequenciestxt
sheetwritetabletallyfile
tallyfileclose 
return 0

figure 32 main driver for computing frequency of letter usage
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 75
a full source code

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43

page 75

include fileutilitiesh
include tallysheeth
include iostream
include fstream
include vector
include algorithm
using namespace std
int main  
ifstream source
ofstream tallyfile
cout  this program tallies a set of integer scores  endl
cout  there should be one integer per line  endl  endl
openfilereadrobustsource
vectorint values
while sourcegood  
int val
source  val
if sourcegood 
valuespush backval
else 
 ignore noninteger line
sourceclear 
sourceignorestdnumeric limitsintmax  n


sourceclose 
int small large
small  min elementvaluesbegin  valuesend 
large  max elementvaluesbegin  valuesend 
tallysheetint sheetsmall large
for int i0 i  valuessize  i
sheetincrementvaluesi
openfilewriterobusttallyfile frequenciestxt
sheetwritetabletallyfile
tallyfileclose 
cout  the tally has been written  endl
return 0

figure 33 main driver for computing frequency of integer scores

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 76
a full source code

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44

page 76

ifndef score h
define score h



brief a score for a single turn from game of mastermind






a black component designates the number of pegs that are
exact matches for the answer a white component counts
pegs that are correctly colored but not well positioned


class score 
private
int numblack
int numwhite

public

 brief create score with given black and white components




param numblack the black component of the score
param white the white component of the score


scoreconst int numblack const int numwhite
 numblacknumblack numwhitenumwhite  


 inlined implementation




brief get the black component of the score



return the number of pegs scored as black

int getnumblack  const 
return numblack
 inlined implementation







brief get the white component of the score




return the number of pegs scored as white


int getnumwhite  const 
return numwhite


 inlined implementation


endif
figure 34 contents of scoreh file for mastermind project no scorecpp is necessary since all
function bodies are inlined
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 77
a full source code

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45

page 77

ifndef pattern h
define pattern h
include scoreh
include vector



brief class for storing a color pattern for mastermind


class pattern 
private
stdvectorint peglist

public

 brief construct a new pattern



initially the pattern consists of numpegs pegs each set to color 0



param numpegs the length of the pattern

patternconst int numpegs






brief return the length of the current pattern



return the length of the pattern

int len  const






brief return the current color setting an integer of the specified peg





param index the index of the peg
return the pegs color


int getpegcolorconst int index const





brief set the color of a peg at the given index of the pattern





param index the index of the peg
param colorid the desired color identifier an integer


void setpegcolorconst int index const int colorid


figure 35 contents of patternh file continued on next page
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 78
a full source code

page 78

46

47
 brief compare the current pattern to another and calculate the score
48

49
 param otherpattern the pattern to be compared to the current one
50
 return a score instance representing the result
51

52
score comparetoconst pattern otherpattern const
53
54

55
 brief make a random pattern
56

57
 param numcolors the maximum number of colors to use in the pattern
58

59
void randomizeconst int numcolors
60 
61
62 endif
figure 35 continuation contents of patternh file
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

include patternh
include set
include algorithm
include stdlibh
using namespace std

 includes the count method

patternpatternconst int numpegs  peglistnumpegs 
int i
for i0 i  numpegs i
peglisti  0

int patternlen  const 
return peglistsize 

int patterngetpegcolorconst int index const 
return peglistindex

void patternsetpegcolorconst int index const int colorid 
peglistindex  colorid

figure 36 contents of patterncpp file continued on next page

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 79
a full source code

24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65

page 79

score patterncomparetoconst pattern otherpattern const 
 first calculate the black component of the score
int black  0
int i
for i0 i peglistsize  i 
if getpegcolori  otherpatterngetpegcolori 
black


 the white component is a little more difficult to calculate
 first find out the colors used in the current pattern
setint colorsused
setintiterator iter
for i0 i peglistsize  i
if colorsusedcount peglisti  0
colorsusedinsert peglisti
 for each color used find the smaller number of times
 it appears in each pattern and add them up
int white  0
setintiterator coloriter
int color count1 count2
for coloritercolorsusedbegin  coloritercolorsusedend  coloriter 
color  coloriter
count1  count peglistbegin  peglistend  color
count2  countotherpattern peglistbegin  otherpattern peglistend  color
if count1  count2
white  count1
else
white  count2

white  black
 dont count pegs that are paired up
return scoreblack white

void patternrandomizeconst int numcolors 
int i
for i0 i peglistsize  i
setpegcolori rand   numcolors

figure 36 continuation contents of patterncpp file

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 80
a full source code

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43

page 80

ifndef textinput h
define textinput h
include patternh
include string
include vector
using stdstring
using stdvector

brief class for dealing with textbased input for the mastermind game

class textinput 
private
int lengthofpattern
int numcolorsinuse
string palette



public

 brief create a new text input instance


param colornames a list of strings each color must start with a different letter

textinputconst vectorstring colornames






brief ask the user how many pegs in the secret pattern




the length of the pattern is also stored internally




return the length of the pattern


int querylengthofpattern 




brief ask the user how many colors to use for secret pattern




the number of colors is also stored internally



return the number of colors

int querynumberofcolors 



figure 37 contents of textinputh file continued on next page

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 81
a full source code

page 81

44

45
 brief ask the user maximum number of guesses to be allowed
46

47
 return the maximum number of guesses
48

49
int querynumberofturns  const
50
51

52
 brief offer the user a new game
53

54
 return true if accepted false otherwise
55

56
bool querynewgame  const
57
58

59
 brief get a guess from the user and return it as a pattern instance
60

61
 return the pattern entered
62

63
pattern enterguess  const
64
65 private
66

67
 brief robustly prompt the user for an integer from small to large
68

69
int readintconst string prompt int small int large const
70 
71
72 endif
figure 37 continuation contents of textinputh file
1
2
3
4
5
6
7
8
9
10
11

include textinputh
include iostream
include sstream
using namespace std
textinputtextinputconst vectorstring colornames 
lengthofpattern0 numcolorsinuse0 palette 
vectorstringconst iterator iter
for itercolornamesbegin  itercolornamesend  iter
palettepush backiter0

figure 38 contents of textinputcpp file continued on next page

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 82
a full source code

12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53

page 82

int textinput readintconst string prompt int small int large const 
string buffer
int answer  small  1
 intentionally invalid
while small  answer  answer  large 
cout  prompt   from   small   to   large   
cin  buffer
stringstream converter
converter  buffer
converter  answer
if converterfail  
if small  answer  answer  large
cout  integer must be from   small   to   large    endl

else 
cout  that is not a valid integer  endl


return answer

int textinputquerylengthofpattern  
lengthofpattern  readinthow many pegs are in the secret 1 10
return lengthofpattern

int textinputquerynumberofcolors  
numcolorsinuse  readinthow many colors are available 2 palettesize 
return numcolorsinuse

int textinputquerynumberofturns  const 
return readinthow many turns are allowed 1 20

bool textinputquerynewgame  const 
cout  endl
cout  would you like to play again   endl
string answer
cin  answer
return answer  y answer  y answer  yes
answer  yes answer  yes

figure 38 continuation contents of textinputcpp file continued on next page

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 83
a full source code

page 83

54 pattern textinputenterguess  const 
55
pattern pattern lengthofpattern
56
string currentpalette  palettesubstr0 numcolorsinuse
57
string patternstring
58
int i
59
bool validpattern  false
60
while not validpattern 
61
cout  endl
62
cout  enter a guess colors are 
63
cout  palettesubstr0 numcolorsinuse   
64
cin  patternstring
65
66
validpattern  true
67
if patternstringsize   lengthofpattern 
68
cout  the pattern must have   lengthofpattern   pegs  endl
69
validpattern  false
70
 else 
71
for i0 i lengthofpattern i
72
if currentpalettefindtoupperpatternstringi  lengthofpattern
73
validpattern  false
74
if validpattern
75
cout  the color options are   currentpalette  endl
76

77
78
if validpattern 
79
for i0 i lengthofpattern i
80
patternsetpegcolori palettefindtoupperpatternstringi
81

82

83
84
return pattern
85 
figure 38 continuation contents of textinputcpp file
1
2
3
4
5
6
7
8
9

ifndef textoutput h
define textoutput h
include patternh
include scoreh
include string
include vector
using stdstring
using stdvector
figure 39 contents of textoutputh file continued on next page
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 84
a full source code

10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55

page 84


brief provide textbased output for the mastermind game

class textoutput 
private
string coloroptions
int currentturnnum
int lengthofpattern
int maxnumberofturns



public

 brief construct a new textoutput instance


param colornames a sequence of strings each color must start with a different letter

textoutputconst vectorstring colornames




brief game is beginning with specified parameters

void startgameint lengthofpattern int maxnumberofturns




brief display recent guess pattern and resulting score to the screen

void displayturnconst pattern guess const score result




brief inform the player that heshe has correctly matched the secret pattern

void announcevictoryconst pattern secret const






brief inform the player that heshe has lost and reveal the secret pattern


void announcedefeatconst pattern secret const

private

 brief returns string representation of given pattern using color shorthands

string patternasstringconst pattern thepattern const

endif
figure 39 continuation contents of textoutputh file
a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 85
a full source code

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44

page 85

include textoutputh
include iostream
using namespace std
textoutputtextoutputconst vectorstring colornames 
currentturnnum0 lengthofpattern0 maxnumberofturns0 coloroptions 
vectorstringconst iterator iter
for itercolornamesbegin  itercolornamesend  iter
coloroptionspush backiter0

void textoutputstartgameint lengthofpattern int maxnumberofturns 
currentturnnum  0
lengthofpattern  lengthofpattern
maxnumberofturns  maxnumberofturns

void textoutputdisplayturnconst pattern guess const score result 
currentturnnum
cout  on turn   currentturnnum   of   maxnumberofturns
  guess   patternasstringguess   scored 
 resultgetnumblack    black and   resultgetnumwhite 
  white  endl

void textoutputannouncevictoryconst pattern secret const 
cout  endl
cout  congratulations you won  endl
cout  the secret was   patternasstringsecret  endl

void textoutputannouncedefeatconst pattern secret const 
cout  endl
cout  the secret was   patternasstringsecret  endl
cout  good luck next time  endl

string textoutput patternasstringconst pattern thepattern const 
string display
int i
for i0 i lengthofpattern i
displaypush back coloroptionsthepatterngetpegcolori
return display

figure 40 contents of textoutputcpp file

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 86
a full source code

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31

page 86

ifndef mastermind h
define mastermind h
include textinputh
include textoutputh



brief main class for the mastermind game


class mastermind 
private
textinput inputmanager
textoutput outputmanager

public

 brief create a new instance of the mastermind game




param inputmanager instance of class that gathers input from the user
param outputmanager instance of class that displays output to the user


mastermindtextinput inputmanager textoutput outputmanager


private

 brief play one game

void runsinglegame 

endif
figure 41 contents of mastermindh file

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 87
a full source code

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41

page 87

include mastermindh
mastermindmastermindtextinput inputmanager textoutput outputmanager 
inputmanagerinputmanager outputmanageroutputmanager 
bool playagain  true
while playagain 
runsinglegame 
playagain  inputmanagerquerynewgame 


void mastermind runsinglegame  
 get parameters from the user
int lengthofpattern  inputmanagerquerylengthofpattern 
int numberofcolors  inputmanagerquerynumberofcolors 
int maxnumberofturns  inputmanagerquerynumberofturns 
outputmanagerstartgamelengthofpattern maxnumberofturns
 pick a new secret
pattern secretlengthofpattern
secretrandomizenumberofcolors
 start playing
int round  0
pattern guesslengthofpattern
bool victory  false
while round  maxnumberofturns  victory 
round
 enact a single turn
guess  inputmanagerenterguess 
score result  guesscomparetosecret
outputmanagerdisplayturnguess result
if resultgetnumblack   lengthofpattern
victory  true

if victory
outputmanagerannouncevictorysecret
else
outputmanagerannouncedefeatsecret

figure 42 contents of mastermindcpp file

a transition guide from python to c

michael h goldwasser and david letscher


$$@@$$PAGE: 88
a full source code

page 88

1 include mastermindh
2
3 int main  
4
vectorstring palette
5
palettepush backred
6
palettepush backblue
7
palettepush backgreen
8
palettepush backwhite
9
palettepush backyellow
10
palettepush backorange
11
palettepush backpurple
12
palettepush backturquoise
13
14
textinput inputpalette
15
textoutput outputpalette
16
mastermind gameinput output
17
18
return 0
19 
figure 43 contents of mastermind maincpp file

a transition guide from python to c

michael h goldwasser and david letscher

